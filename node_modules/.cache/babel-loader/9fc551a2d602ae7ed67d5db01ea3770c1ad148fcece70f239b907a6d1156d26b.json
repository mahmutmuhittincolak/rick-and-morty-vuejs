{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\nconst path = require(\"path\");\nconst DescriptionFileUtils = require(\"./DescriptionFileUtils\");\nconst forEachBail = require(\"./forEachBail\");\nconst {\n  processImportsField\n} = require(\"./util/entrypoints\");\nconst {\n  parseIdentifier\n} = require(\"./util/identifier\");\nconst {\n  checkImportsExportsFieldTarget\n} = require(\"./util/path\");\n\n/** @typedef {import(\"./Resolver\")} Resolver */\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\n/** @typedef {import(\"./util/entrypoints\").FieldProcessor} FieldProcessor */\n/** @typedef {import(\"./util/entrypoints\").ImportsField} ImportsField */\n\nconst dotCode = \".\".charCodeAt(0);\nmodule.exports = class ImportsFieldPlugin {\n  /**\n   * @param {string | ResolveStepHook} source source\n   * @param {Set<string>} conditionNames condition names\n   * @param {string | string[]} fieldNamePath name path\n   * @param {string | ResolveStepHook} targetFile target file\n   * @param {string | ResolveStepHook} targetPackage target package\n   */\n  constructor(source, conditionNames, fieldNamePath, targetFile, targetPackage) {\n    this.source = source;\n    this.targetFile = targetFile;\n    this.targetPackage = targetPackage;\n    this.conditionNames = conditionNames;\n    this.fieldName = fieldNamePath;\n    /** @type {WeakMap<any, FieldProcessor>} */\n    this.fieldProcessorCache = new WeakMap();\n  }\n\n  /**\n   * @param {Resolver} resolver the resolver\n   * @returns {void}\n   */\n  apply(resolver) {\n    const targetFile = resolver.ensureHook(this.targetFile);\n    const targetPackage = resolver.ensureHook(this.targetPackage);\n    resolver.getHook(this.source).tapAsync(\"ImportsFieldPlugin\", (request, resolveContext, callback) => {\n      // When there is no description file, abort\n      if (!request.descriptionFilePath || request.request === undefined) {\n        return callback();\n      }\n      const remainingRequest = request.request + request.query + request.fragment;\n      /** @type {ImportsField|null} */\n      const importsField = DescriptionFileUtils.getField(request.descriptionFileData, this.fieldName);\n      if (!importsField) return callback();\n      if (request.directory) {\n        return callback(new Error(`Resolving to directories is not possible with the imports field (request was ${remainingRequest}/)`));\n      }\n      let paths;\n      try {\n        // We attach the cache to the description file instead of the importsField value\n        // because we use a WeakMap and the importsField could be a string too.\n        // Description file is always an object when exports field can be accessed.\n        let fieldProcessor = this.fieldProcessorCache.get(request.descriptionFileData);\n        if (fieldProcessor === undefined) {\n          fieldProcessor = processImportsField(importsField);\n          this.fieldProcessorCache.set(request.descriptionFileData, fieldProcessor);\n        }\n        paths = fieldProcessor(remainingRequest, this.conditionNames);\n      } catch (err) {\n        if (resolveContext.log) {\n          resolveContext.log(`Imports field in ${request.descriptionFilePath} can't be processed: ${err}`);\n        }\n        return callback(err);\n      }\n      if (paths.length === 0) {\n        return callback(new Error(`Package import ${remainingRequest} is not imported from package ${request.descriptionFileRoot} (see imports field in ${request.descriptionFilePath})`));\n      }\n      forEachBail(paths, (p, callback) => {\n        const parsedIdentifier = parseIdentifier(p);\n        if (!parsedIdentifier) return callback();\n        const [path_, query, fragment] = parsedIdentifier;\n        const error = checkImportsExportsFieldTarget(path_);\n        if (error) {\n          return callback(error);\n        }\n        switch (path_.charCodeAt(0)) {\n          // should be relative\n          case dotCode:\n            {\n              const obj = {\n                ...request,\n                request: undefined,\n                path: path.join( /** @type {string} */request.descriptionFileRoot, path_),\n                relativePath: path_,\n                query,\n                fragment\n              };\n              resolver.doResolve(targetFile, obj, \"using imports field: \" + p, resolveContext, callback);\n              break;\n            }\n\n          // package resolving\n          default:\n            {\n              const obj = {\n                ...request,\n                request: path_,\n                relativePath: path_,\n                fullySpecified: true,\n                query,\n                fragment\n              };\n              resolver.doResolve(targetPackage, obj, \"using imports field: \" + p, resolveContext, callback);\n            }\n        }\n      }, (err, result) => callback(err, result || null));\n    });\n  }\n};","map":{"version":3,"names":["path","require","DescriptionFileUtils","forEachBail","processImportsField","parseIdentifier","checkImportsExportsFieldTarget","dotCode","charCodeAt","module","exports","ImportsFieldPlugin","constructor","source","conditionNames","fieldNamePath","targetFile","targetPackage","fieldName","fieldProcessorCache","WeakMap","apply","resolver","ensureHook","getHook","tapAsync","request","resolveContext","callback","descriptionFilePath","undefined","remainingRequest","query","fragment","importsField","getField","descriptionFileData","directory","Error","paths","fieldProcessor","get","set","err","log","length","descriptionFileRoot","p","parsedIdentifier","path_","error","obj","join","relativePath","doResolve","fullySpecified","result"],"sources":["C:/Users/mahmutcolak/Desktop/rick-and-morty/node_modules/enhanced-resolve/lib/ImportsFieldPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\nconst path = require(\"path\");\nconst DescriptionFileUtils = require(\"./DescriptionFileUtils\");\nconst forEachBail = require(\"./forEachBail\");\nconst { processImportsField } = require(\"./util/entrypoints\");\nconst { parseIdentifier } = require(\"./util/identifier\");\nconst { checkImportsExportsFieldTarget } = require(\"./util/path\");\n\n/** @typedef {import(\"./Resolver\")} Resolver */\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\n/** @typedef {import(\"./util/entrypoints\").FieldProcessor} FieldProcessor */\n/** @typedef {import(\"./util/entrypoints\").ImportsField} ImportsField */\n\nconst dotCode = \".\".charCodeAt(0);\n\nmodule.exports = class ImportsFieldPlugin {\n\t/**\n\t * @param {string | ResolveStepHook} source source\n\t * @param {Set<string>} conditionNames condition names\n\t * @param {string | string[]} fieldNamePath name path\n\t * @param {string | ResolveStepHook} targetFile target file\n\t * @param {string | ResolveStepHook} targetPackage target package\n\t */\n\tconstructor(\n\t\tsource,\n\t\tconditionNames,\n\t\tfieldNamePath,\n\t\ttargetFile,\n\t\ttargetPackage\n\t) {\n\t\tthis.source = source;\n\t\tthis.targetFile = targetFile;\n\t\tthis.targetPackage = targetPackage;\n\t\tthis.conditionNames = conditionNames;\n\t\tthis.fieldName = fieldNamePath;\n\t\t/** @type {WeakMap<any, FieldProcessor>} */\n\t\tthis.fieldProcessorCache = new WeakMap();\n\t}\n\n\t/**\n\t * @param {Resolver} resolver the resolver\n\t * @returns {void}\n\t */\n\tapply(resolver) {\n\t\tconst targetFile = resolver.ensureHook(this.targetFile);\n\t\tconst targetPackage = resolver.ensureHook(this.targetPackage);\n\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"ImportsFieldPlugin\", (request, resolveContext, callback) => {\n\t\t\t\t// When there is no description file, abort\n\t\t\t\tif (!request.descriptionFilePath || request.request === undefined) {\n\t\t\t\t\treturn callback();\n\t\t\t\t}\n\n\t\t\t\tconst remainingRequest =\n\t\t\t\t\trequest.request + request.query + request.fragment;\n\t\t\t\t/** @type {ImportsField|null} */\n\t\t\t\tconst importsField = DescriptionFileUtils.getField(\n\t\t\t\t\trequest.descriptionFileData,\n\t\t\t\t\tthis.fieldName\n\t\t\t\t);\n\t\t\t\tif (!importsField) return callback();\n\n\t\t\t\tif (request.directory) {\n\t\t\t\t\treturn callback(\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t`Resolving to directories is not possible with the imports field (request was ${remainingRequest}/)`\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlet paths;\n\n\t\t\t\ttry {\n\t\t\t\t\t// We attach the cache to the description file instead of the importsField value\n\t\t\t\t\t// because we use a WeakMap and the importsField could be a string too.\n\t\t\t\t\t// Description file is always an object when exports field can be accessed.\n\t\t\t\t\tlet fieldProcessor = this.fieldProcessorCache.get(\n\t\t\t\t\t\trequest.descriptionFileData\n\t\t\t\t\t);\n\t\t\t\t\tif (fieldProcessor === undefined) {\n\t\t\t\t\t\tfieldProcessor = processImportsField(importsField);\n\t\t\t\t\t\tthis.fieldProcessorCache.set(\n\t\t\t\t\t\t\trequest.descriptionFileData,\n\t\t\t\t\t\t\tfieldProcessor\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tpaths = fieldProcessor(remainingRequest, this.conditionNames);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (resolveContext.log) {\n\t\t\t\t\t\tresolveContext.log(\n\t\t\t\t\t\t\t`Imports field in ${request.descriptionFilePath} can't be processed: ${err}`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\n\t\t\t\tif (paths.length === 0) {\n\t\t\t\t\treturn callback(\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t`Package import ${remainingRequest} is not imported from package ${request.descriptionFileRoot} (see imports field in ${request.descriptionFilePath})`\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tforEachBail(\n\t\t\t\t\tpaths,\n\t\t\t\t\t(p, callback) => {\n\t\t\t\t\t\tconst parsedIdentifier = parseIdentifier(p);\n\n\t\t\t\t\t\tif (!parsedIdentifier) return callback();\n\n\t\t\t\t\t\tconst [path_, query, fragment] = parsedIdentifier;\n\n\t\t\t\t\t\tconst error = checkImportsExportsFieldTarget(path_);\n\n\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\treturn callback(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tswitch (path_.charCodeAt(0)) {\n\t\t\t\t\t\t\t// should be relative\n\t\t\t\t\t\t\tcase dotCode: {\n\t\t\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\t\t\t...request,\n\t\t\t\t\t\t\t\t\trequest: undefined,\n\t\t\t\t\t\t\t\t\tpath: path.join(\n\t\t\t\t\t\t\t\t\t\t/** @type {string} */ (request.descriptionFileRoot),\n\t\t\t\t\t\t\t\t\t\tpath_\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\trelativePath: path_,\n\t\t\t\t\t\t\t\t\tquery,\n\t\t\t\t\t\t\t\t\tfragment\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tresolver.doResolve(\n\t\t\t\t\t\t\t\t\ttargetFile,\n\t\t\t\t\t\t\t\t\tobj,\n\t\t\t\t\t\t\t\t\t\"using imports field: \" + p,\n\t\t\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// package resolving\n\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\t\t\t...request,\n\t\t\t\t\t\t\t\t\trequest: path_,\n\t\t\t\t\t\t\t\t\trelativePath: path_,\n\t\t\t\t\t\t\t\t\tfullySpecified: true,\n\t\t\t\t\t\t\t\t\tquery,\n\t\t\t\t\t\t\t\t\tfragment\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tresolver.doResolve(\n\t\t\t\t\t\t\t\t\ttargetPackage,\n\t\t\t\t\t\t\t\t\tobj,\n\t\t\t\t\t\t\t\t\t\"using imports field: \" + p,\n\t\t\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t(err, result) => callback(err, result || null)\n\t\t\t\t);\n\t\t\t});\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}