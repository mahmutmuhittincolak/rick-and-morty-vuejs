{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction findParent(_ref, cb) {\n  var parentPath = _ref.parentPath;\n  if (parentPath == null) {\n    throw new Error(\"node is root\");\n  }\n  var currentPath = parentPath;\n  while (cb(currentPath) !== false) {\n    // Hit the root node, stop\n    // $FlowIgnore\n    if (currentPath.parentPath == null) {\n      return null;\n    } // $FlowIgnore\n\n    currentPath = currentPath.parentPath;\n  }\n  return currentPath.node;\n}\nfunction insertBefore(context, newNode) {\n  return insert(context, newNode);\n}\nfunction insertAfter(context, newNode) {\n  return insert(context, newNode, 1);\n}\nfunction insert(_ref2, newNode) {\n  var node = _ref2.node,\n    inList = _ref2.inList,\n    parentPath = _ref2.parentPath,\n    parentKey = _ref2.parentKey;\n  var indexOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  if (!inList) {\n    throw new Error('inList' + \" error: \" + (\"insert can only be used for nodes that are within lists\" || \"unknown\"));\n  }\n  if (!(parentPath != null)) {\n    throw new Error('parentPath != null' + \" error: \" + (\"Can not remove root node\" || \"unknown\"));\n  }\n\n  // $FlowIgnore\n  var parentList = parentPath.node[parentKey];\n  var indexInList = parentList.findIndex(function (n) {\n    return n === node;\n  });\n  parentList.splice(indexInList + indexOffset, 0, newNode);\n}\nfunction remove(_ref3) {\n  var node = _ref3.node,\n    parentKey = _ref3.parentKey,\n    parentPath = _ref3.parentPath;\n  if (!(parentPath != null)) {\n    throw new Error('parentPath != null' + \" error: \" + (\"Can not remove root node\" || \"unknown\"));\n  }\n\n  // $FlowIgnore\n  var parentNode = parentPath.node; // $FlowIgnore\n\n  var parentProperty = parentNode[parentKey];\n  if (Array.isArray(parentProperty)) {\n    // $FlowIgnore\n    parentNode[parentKey] = parentProperty.filter(function (n) {\n      return n !== node;\n    });\n  } else {\n    // $FlowIgnore\n    delete parentNode[parentKey];\n  }\n  node._deleted = true;\n}\nfunction stop(context) {\n  context.shouldStop = true;\n}\nfunction replaceWith(context, newNode) {\n  // $FlowIgnore\n  var parentNode = context.parentPath.node; // $FlowIgnore\n\n  var parentProperty = parentNode[context.parentKey];\n  if (Array.isArray(parentProperty)) {\n    var indexInList = parentProperty.findIndex(function (n) {\n      return n === context.node;\n    });\n    parentProperty.splice(indexInList, 1, newNode);\n  } else {\n    // $FlowIgnore\n    parentNode[context.parentKey] = newNode;\n  }\n  context.node._deleted = true;\n  context.node = newNode;\n} // bind the context to the first argument of node operations\n\nfunction bindNodeOperations(operations, context) {\n  var keys = Object.keys(operations);\n  var boundOperations = {};\n  keys.forEach(function (key) {\n    boundOperations[key] = operations[key].bind(null, context);\n  });\n  return boundOperations;\n}\nfunction createPathOperations(context) {\n  // $FlowIgnore\n  return bindNodeOperations({\n    findParent: findParent,\n    replaceWith: replaceWith,\n    remove: remove,\n    insertBefore: insertBefore,\n    insertAfter: insertAfter,\n    stop: stop\n  }, context);\n}\nexport function createPath(context) {\n  var path = _extends({}, context); // $FlowIgnore\n\n  Object.assign(path, createPathOperations(path)); // $FlowIgnore\n\n  return path;\n}","map":{"version":3,"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","findParent","_ref","cb","parentPath","Error","currentPath","node","insertBefore","context","newNode","insert","insertAfter","_ref2","inList","parentKey","indexOffset","undefined","parentList","indexInList","findIndex","n","splice","remove","_ref3","parentNode","parentProperty","Array","isArray","filter","_deleted","stop","shouldStop","replaceWith","bindNodeOperations","operations","keys","boundOperations","forEach","bind","createPathOperations","createPath","path"],"sources":["C:/Users/mahmutcolak/Desktop/rick-and-morty/node_modules/@webassemblyjs/ast/esm/node-path.js"],"sourcesContent":["function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction findParent(_ref, cb) {\n  var parentPath = _ref.parentPath;\n\n  if (parentPath == null) {\n    throw new Error(\"node is root\");\n  }\n\n  var currentPath = parentPath;\n\n  while (cb(currentPath) !== false) {\n    // Hit the root node, stop\n    // $FlowIgnore\n    if (currentPath.parentPath == null) {\n      return null;\n    } // $FlowIgnore\n\n\n    currentPath = currentPath.parentPath;\n  }\n\n  return currentPath.node;\n}\n\nfunction insertBefore(context, newNode) {\n  return insert(context, newNode);\n}\n\nfunction insertAfter(context, newNode) {\n  return insert(context, newNode, 1);\n}\n\nfunction insert(_ref2, newNode) {\n  var node = _ref2.node,\n      inList = _ref2.inList,\n      parentPath = _ref2.parentPath,\n      parentKey = _ref2.parentKey;\n  var indexOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n  if (!inList) {\n    throw new Error('inList' + \" error: \" + (\"insert can only be used for nodes that are within lists\" || \"unknown\"));\n  }\n\n  if (!(parentPath != null)) {\n    throw new Error('parentPath != null' + \" error: \" + (\"Can not remove root node\" || \"unknown\"));\n  }\n\n  // $FlowIgnore\n  var parentList = parentPath.node[parentKey];\n  var indexInList = parentList.findIndex(function (n) {\n    return n === node;\n  });\n  parentList.splice(indexInList + indexOffset, 0, newNode);\n}\n\nfunction remove(_ref3) {\n  var node = _ref3.node,\n      parentKey = _ref3.parentKey,\n      parentPath = _ref3.parentPath;\n\n  if (!(parentPath != null)) {\n    throw new Error('parentPath != null' + \" error: \" + (\"Can not remove root node\" || \"unknown\"));\n  }\n\n  // $FlowIgnore\n  var parentNode = parentPath.node; // $FlowIgnore\n\n  var parentProperty = parentNode[parentKey];\n\n  if (Array.isArray(parentProperty)) {\n    // $FlowIgnore\n    parentNode[parentKey] = parentProperty.filter(function (n) {\n      return n !== node;\n    });\n  } else {\n    // $FlowIgnore\n    delete parentNode[parentKey];\n  }\n\n  node._deleted = true;\n}\n\nfunction stop(context) {\n  context.shouldStop = true;\n}\n\nfunction replaceWith(context, newNode) {\n  // $FlowIgnore\n  var parentNode = context.parentPath.node; // $FlowIgnore\n\n  var parentProperty = parentNode[context.parentKey];\n\n  if (Array.isArray(parentProperty)) {\n    var indexInList = parentProperty.findIndex(function (n) {\n      return n === context.node;\n    });\n    parentProperty.splice(indexInList, 1, newNode);\n  } else {\n    // $FlowIgnore\n    parentNode[context.parentKey] = newNode;\n  }\n\n  context.node._deleted = true;\n  context.node = newNode;\n} // bind the context to the first argument of node operations\n\n\nfunction bindNodeOperations(operations, context) {\n  var keys = Object.keys(operations);\n  var boundOperations = {};\n  keys.forEach(function (key) {\n    boundOperations[key] = operations[key].bind(null, context);\n  });\n  return boundOperations;\n}\n\nfunction createPathOperations(context) {\n  // $FlowIgnore\n  return bindNodeOperations({\n    findParent: findParent,\n    replaceWith: replaceWith,\n    remove: remove,\n    insertBefore: insertBefore,\n    insertAfter: insertAfter,\n    stop: stop\n  }, context);\n}\n\nexport function createPath(context) {\n  var path = _extends({}, context); // $FlowIgnore\n\n\n  Object.assign(path, createPathOperations(path)); // $FlowIgnore\n\n  return path;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}