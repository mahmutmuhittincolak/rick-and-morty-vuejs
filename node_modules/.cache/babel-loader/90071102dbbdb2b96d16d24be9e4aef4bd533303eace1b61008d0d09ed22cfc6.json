{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.importAssertions = importAssertions;\nvar _acorn = _interopRequireWildcard(require(\"acorn\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nconst leftCurlyBrace = \"{\".charCodeAt(0);\nconst space = \" \".charCodeAt(0);\nconst keyword = \"assert\";\nconst FUNC_STATEMENT = 1,\n  FUNC_HANGING_STATEMENT = 2,\n  FUNC_NULLABLE_ID = 4;\nfunction importAssertions(Parser) {\n  // Use supplied version acorn version if present, to avoid\n  // reference mismatches due to different acorn versions. This\n  // allows this plugin to be used with Rollup which supplies\n  // its own internal version of acorn and thereby sidesteps\n  // the package manager.\n  const acorn = Parser.acorn || _acorn;\n  const {\n    tokTypes: tt,\n    TokenType\n  } = acorn;\n  return class extends Parser {\n    constructor(...args) {\n      super(...args);\n      this.assertToken = new TokenType(keyword);\n    }\n    _codeAt(i) {\n      return this.input.charCodeAt(i);\n    }\n    _eat(t) {\n      if (this.type !== t) {\n        this.unexpected();\n      }\n      this.next();\n    }\n    readToken(code) {\n      let i = 0;\n      for (; i < keyword.length; i++) {\n        if (this._codeAt(this.pos + i) !== keyword.charCodeAt(i)) {\n          return super.readToken(code);\n        }\n      } // ensure that the keyword is at the correct location\n      // ie `assert{...` or `assert {...`\n\n      for (;; i++) {\n        if (this._codeAt(this.pos + i) === leftCurlyBrace) {\n          // Found '{'\n          break;\n        } else if (this._codeAt(this.pos + i) === space) {\n          // white space is allowed between `assert` and `{`, so continue.\n          continue;\n        } else {\n          return super.readToken(code);\n        }\n      } // If we're inside a dynamic import expression we'll parse\n      // the `assert` keyword as a standard object property name\n      // ie `import(\"\"./foo.json\", { assert: { type: \"json\" } })`\n\n      if (this.type.label === \"{\") {\n        return super.readToken(code);\n      }\n      this.pos += keyword.length;\n      return this.finishToken(this.assertToken);\n    }\n    parseDynamicImport(node) {\n      this.next(); // skip `(`\n      // Parse node.source.\n\n      node.source = this.parseMaybeAssign();\n      if (this.eat(tt.comma)) {\n        const obj = this.parseObj(false);\n        node.arguments = [obj];\n      }\n      this._eat(tt.parenR);\n      return this.finishNode(node, \"ImportExpression\");\n    } // ported from acorn/src/statement.js pp.parseExport\n\n    parseExport(node, exports) {\n      this.next(); // export * from '...'\n\n      if (this.eat(tt.star)) {\n        if (this.options.ecmaVersion >= 11) {\n          if (this.eatContextual(\"as\")) {\n            node.exported = this.parseIdent(true);\n            this.checkExport(exports, node.exported.name, this.lastTokStart);\n          } else {\n            node.exported = null;\n          }\n        }\n        this.expectContextual(\"from\");\n        if (this.type !== tt.string) {\n          this.unexpected();\n        }\n        node.source = this.parseExprAtom();\n        if (this.type === this.assertToken) {\n          this.next();\n          const assertions = this.parseImportAssertions();\n          if (assertions) {\n            node.assertions = assertions;\n          }\n        }\n        this.semicolon();\n        return this.finishNode(node, \"ExportAllDeclaration\");\n      }\n      if (this.eat(tt._default)) {\n        // export default ...\n        this.checkExport(exports, \"default\", this.lastTokStart);\n        var isAsync;\n        if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {\n          var fNode = this.startNode();\n          this.next();\n          if (isAsync) {\n            this.next();\n          }\n          node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n        } else if (this.type === tt._class) {\n          var cNode = this.startNode();\n          node.declaration = this.parseClass(cNode, \"nullableID\");\n        } else {\n          node.declaration = this.parseMaybeAssign();\n          this.semicolon();\n        }\n        return this.finishNode(node, \"ExportDefaultDeclaration\");\n      } // export var|const|let|function|class ...\n\n      if (this.shouldParseExportStatement()) {\n        node.declaration = this.parseStatement(null);\n        if (node.declaration.type === \"VariableDeclaration\") {\n          this.checkVariableExport(exports, node.declaration.declarations);\n        } else {\n          this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);\n        }\n        node.specifiers = [];\n        node.source = null;\n      } else {\n        // export { x, y as z } [from '...']\n        node.declaration = null;\n        node.specifiers = this.parseExportSpecifiers(exports);\n        if (this.eatContextual(\"from\")) {\n          if (this.type !== tt.string) {\n            this.unexpected();\n          }\n          node.source = this.parseExprAtom();\n          if (this.type === this.assertToken) {\n            this.next();\n            const assertions = this.parseImportAssertions();\n            if (assertions) {\n              node.assertions = assertions;\n            }\n          }\n        } else {\n          for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n            // check for keywords used as local names\n            var spec = list[i];\n            this.checkUnreserved(spec.local); // check if export is defined\n\n            this.checkLocalExport(spec.local);\n          }\n          node.source = null;\n        }\n        this.semicolon();\n      }\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n    parseImport(node) {\n      this.next(); // import '...'\n\n      if (this.type === tt.string) {\n        node.specifiers = [];\n        node.source = this.parseExprAtom();\n      } else {\n        node.specifiers = this.parseImportSpecifiers();\n        this.expectContextual(\"from\");\n        node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();\n      }\n      if (this.type === this.assertToken) {\n        this.next();\n        const assertions = this.parseImportAssertions();\n        if (assertions) {\n          node.assertions = assertions;\n        }\n      }\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n    parseImportAssertions() {\n      this._eat(tt.braceL);\n      const attrs = this.parseAssertEntries();\n      this._eat(tt.braceR);\n      return attrs;\n    }\n    parseAssertEntries() {\n      const attrs = [];\n      const attrNames = new Set();\n      do {\n        if (this.type === tt.braceR) {\n          break;\n        }\n        const node = this.startNode(); // parse AssertionKey : IdentifierName, StringLiteral\n\n        let assertionKeyNode;\n        if (this.type === tt.string) {\n          assertionKeyNode = this.parseLiteral(this.value);\n        } else {\n          assertionKeyNode = this.parseIdent(true);\n        }\n        this.next();\n        node.key = assertionKeyNode; // check if we already have an entry for an attribute\n        // if a duplicate entry is found, throw an error\n        // for now this logic will come into play only when someone declares `type` twice\n\n        if (attrNames.has(node.key.name)) {\n          this.raise(this.pos, \"Duplicated key in assertions\");\n        }\n        attrNames.add(node.key.name);\n        if (this.type !== tt.string) {\n          this.raise(this.pos, \"Only string is supported as an assertion value\");\n        }\n        node.value = this.parseLiteral(this.value);\n        attrs.push(this.finishNode(node, \"ImportAttribute\"));\n      } while (this.eat(tt.comma));\n      return attrs;\n    }\n  };\n}","map":{"version":3,"names":["require","Object","defineProperty","exports","value","importAssertions","_acorn","_interopRequireWildcard","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","default","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","leftCurlyBrace","charCodeAt","space","keyword","FUNC_STATEMENT","FUNC_HANGING_STATEMENT","FUNC_NULLABLE_ID","Parser","acorn","tokTypes","tt","TokenType","constructor","args","assertToken","_codeAt","i","input","_eat","t","type","unexpected","next","readToken","code","length","pos","label","finishToken","parseDynamicImport","node","source","parseMaybeAssign","eat","comma","parseObj","arguments","parenR","finishNode","parseExport","star","options","ecmaVersion","eatContextual","exported","parseIdent","checkExport","name","lastTokStart","expectContextual","string","parseExprAtom","assertions","parseImportAssertions","semicolon","_default","isAsync","_function","isAsyncFunction","fNode","startNode","declaration","parseFunction","_class","cNode","parseClass","shouldParseExportStatement","parseStatement","checkVariableExport","declarations","id","start","specifiers","parseExportSpecifiers","list","spec","checkUnreserved","local","checkLocalExport","parseImport","parseImportSpecifiers","braceL","attrs","parseAssertEntries","braceR","attrNames","Set","assertionKeyNode","parseLiteral","raise","add","push"],"sources":["C:/Users/mahmutcolak/Desktop/rick-and-morty/node_modules/acorn-import-assertions/lib/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.importAssertions = importAssertions;\n\nvar _acorn = _interopRequireWildcard(require(\"acorn\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst leftCurlyBrace = \"{\".charCodeAt(0);\nconst space = \" \".charCodeAt(0);\nconst keyword = \"assert\";\nconst FUNC_STATEMENT = 1,\n      FUNC_HANGING_STATEMENT = 2,\n      FUNC_NULLABLE_ID = 4;\n\nfunction importAssertions(Parser) {\n  // Use supplied version acorn version if present, to avoid\n  // reference mismatches due to different acorn versions. This\n  // allows this plugin to be used with Rollup which supplies\n  // its own internal version of acorn and thereby sidesteps\n  // the package manager.\n  const acorn = Parser.acorn || _acorn;\n  const {\n    tokTypes: tt,\n    TokenType\n  } = acorn;\n  return class extends Parser {\n    constructor(...args) {\n      super(...args);\n      this.assertToken = new TokenType(keyword);\n    }\n\n    _codeAt(i) {\n      return this.input.charCodeAt(i);\n    }\n\n    _eat(t) {\n      if (this.type !== t) {\n        this.unexpected();\n      }\n\n      this.next();\n    }\n\n    readToken(code) {\n      let i = 0;\n\n      for (; i < keyword.length; i++) {\n        if (this._codeAt(this.pos + i) !== keyword.charCodeAt(i)) {\n          return super.readToken(code);\n        }\n      } // ensure that the keyword is at the correct location\n      // ie `assert{...` or `assert {...`\n\n\n      for (;; i++) {\n        if (this._codeAt(this.pos + i) === leftCurlyBrace) {\n          // Found '{'\n          break;\n        } else if (this._codeAt(this.pos + i) === space) {\n          // white space is allowed between `assert` and `{`, so continue.\n          continue;\n        } else {\n          return super.readToken(code);\n        }\n      } // If we're inside a dynamic import expression we'll parse\n      // the `assert` keyword as a standard object property name\n      // ie `import(\"\"./foo.json\", { assert: { type: \"json\" } })`\n\n\n      if (this.type.label === \"{\") {\n        return super.readToken(code);\n      }\n\n      this.pos += keyword.length;\n      return this.finishToken(this.assertToken);\n    }\n\n    parseDynamicImport(node) {\n      this.next(); // skip `(`\n      // Parse node.source.\n\n      node.source = this.parseMaybeAssign();\n\n      if (this.eat(tt.comma)) {\n        const obj = this.parseObj(false);\n        node.arguments = [obj];\n      }\n\n      this._eat(tt.parenR);\n\n      return this.finishNode(node, \"ImportExpression\");\n    } // ported from acorn/src/statement.js pp.parseExport\n\n\n    parseExport(node, exports) {\n      this.next(); // export * from '...'\n\n      if (this.eat(tt.star)) {\n        if (this.options.ecmaVersion >= 11) {\n          if (this.eatContextual(\"as\")) {\n            node.exported = this.parseIdent(true);\n            this.checkExport(exports, node.exported.name, this.lastTokStart);\n          } else {\n            node.exported = null;\n          }\n        }\n\n        this.expectContextual(\"from\");\n\n        if (this.type !== tt.string) {\n          this.unexpected();\n        }\n\n        node.source = this.parseExprAtom();\n\n        if (this.type === this.assertToken) {\n          this.next();\n          const assertions = this.parseImportAssertions();\n\n          if (assertions) {\n            node.assertions = assertions;\n          }\n        }\n\n        this.semicolon();\n        return this.finishNode(node, \"ExportAllDeclaration\");\n      }\n\n      if (this.eat(tt._default)) {\n        // export default ...\n        this.checkExport(exports, \"default\", this.lastTokStart);\n        var isAsync;\n\n        if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {\n          var fNode = this.startNode();\n          this.next();\n\n          if (isAsync) {\n            this.next();\n          }\n\n          node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n        } else if (this.type === tt._class) {\n          var cNode = this.startNode();\n          node.declaration = this.parseClass(cNode, \"nullableID\");\n        } else {\n          node.declaration = this.parseMaybeAssign();\n          this.semicolon();\n        }\n\n        return this.finishNode(node, \"ExportDefaultDeclaration\");\n      } // export var|const|let|function|class ...\n\n\n      if (this.shouldParseExportStatement()) {\n        node.declaration = this.parseStatement(null);\n\n        if (node.declaration.type === \"VariableDeclaration\") {\n          this.checkVariableExport(exports, node.declaration.declarations);\n        } else {\n          this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);\n        }\n\n        node.specifiers = [];\n        node.source = null;\n      } else {\n        // export { x, y as z } [from '...']\n        node.declaration = null;\n        node.specifiers = this.parseExportSpecifiers(exports);\n\n        if (this.eatContextual(\"from\")) {\n          if (this.type !== tt.string) {\n            this.unexpected();\n          }\n\n          node.source = this.parseExprAtom();\n\n          if (this.type === this.assertToken) {\n            this.next();\n            const assertions = this.parseImportAssertions();\n\n            if (assertions) {\n              node.assertions = assertions;\n            }\n          }\n        } else {\n          for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n            // check for keywords used as local names\n            var spec = list[i];\n            this.checkUnreserved(spec.local); // check if export is defined\n\n            this.checkLocalExport(spec.local);\n          }\n\n          node.source = null;\n        }\n\n        this.semicolon();\n      }\n\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    parseImport(node) {\n      this.next(); // import '...'\n\n      if (this.type === tt.string) {\n        node.specifiers = [];\n        node.source = this.parseExprAtom();\n      } else {\n        node.specifiers = this.parseImportSpecifiers();\n        this.expectContextual(\"from\");\n        node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();\n      }\n\n      if (this.type === this.assertToken) {\n        this.next();\n        const assertions = this.parseImportAssertions();\n\n        if (assertions) {\n          node.assertions = assertions;\n        }\n      }\n\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n\n    parseImportAssertions() {\n      this._eat(tt.braceL);\n\n      const attrs = this.parseAssertEntries();\n\n      this._eat(tt.braceR);\n\n      return attrs;\n    }\n\n    parseAssertEntries() {\n      const attrs = [];\n      const attrNames = new Set();\n\n      do {\n        if (this.type === tt.braceR) {\n          break;\n        }\n\n        const node = this.startNode(); // parse AssertionKey : IdentifierName, StringLiteral\n\n        let assertionKeyNode;\n\n        if (this.type === tt.string) {\n          assertionKeyNode = this.parseLiteral(this.value);\n        } else {\n          assertionKeyNode = this.parseIdent(true);\n        }\n\n        this.next();\n        node.key = assertionKeyNode; // check if we already have an entry for an attribute\n        // if a duplicate entry is found, throw an error\n        // for now this logic will come into play only when someone declares `type` twice\n\n        if (attrNames.has(node.key.name)) {\n          this.raise(this.pos, \"Duplicated key in assertions\");\n        }\n\n        attrNames.add(node.key.name);\n\n        if (this.type !== tt.string) {\n          this.raise(this.pos, \"Only string is supported as an assertion value\");\n        }\n\n        node.value = this.parseLiteral(this.value);\n        attrs.push(this.finishNode(node, \"ImportAttribute\"));\n      } while (this.eat(tt.comma));\n\n      return attrs;\n    }\n\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}