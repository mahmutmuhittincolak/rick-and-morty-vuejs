{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\n/** @typedef {string|(string|ConditionalMapping)[]} DirectMapping */\n/** @typedef {{[k: string]: MappingValue}} ConditionalMapping */\n/** @typedef {ConditionalMapping|DirectMapping|null} MappingValue */\n/** @typedef {Record<string, MappingValue>|ConditionalMapping|DirectMapping} ExportsField */\n/** @typedef {Record<string, MappingValue>} ImportsField */\n\n/**\n * @typedef {Object} PathTreeNode\n * @property {Map<string, PathTreeNode>|null} children\n * @property {MappingValue} folder\n * @property {Map<string, MappingValue>|null} wildcards\n * @property {Map<string, MappingValue>} files\n */\n\n/**\n * Processing exports/imports field\n * @callback FieldProcessor\n * @param {string} request request\n * @param {Set<string>} conditionNames condition names\n * @returns {string[]} resolved paths\n */\n\n/*\nExample exports field:\n{\n  \".\": \"./main.js\",\n  \"./feature\": {\n    \"browser\": \"./feature-browser.js\",\n    \"default\": \"./feature.js\"\n  }\n}\nTerminology:\n\nEnhanced-resolve name keys (\".\" and \"./feature\") as exports field keys.\n\nIf value is string or string[], mapping is called as a direct mapping\nand value called as a direct export.\n\nIf value is key-value object, mapping is called as a conditional mapping\nand value called as a conditional export.\n\nKey in conditional mapping is called condition name.\n\nConditional mapping nested in another conditional mapping is called nested mapping.\n\n----------\n\nExample imports field:\n{\n  \"#a\": \"./main.js\",\n  \"#moment\": {\n    \"browser\": \"./moment/index.js\",\n    \"default\": \"moment\"\n  },\n  \"#moment/\": {\n    \"browser\": \"./moment/\",\n    \"default\": \"moment/\"\n  }\n}\nTerminology:\n\nEnhanced-resolve name keys (\"#a\" and \"#moment/\", \"#moment\") as imports field keys.\n\nIf value is string or string[], mapping is called as a direct mapping\nand value called as a direct export.\n\nIf value is key-value object, mapping is called as a conditional mapping\nand value called as a conditional export.\n\nKey in conditional mapping is called condition name.\n\nConditional mapping nested in another conditional mapping is called nested mapping.\n\n*/\nrequire(\"core-js/modules/es.array.push.js\");\nconst slashCode = \"/\".charCodeAt(0);\nconst dotCode = \".\".charCodeAt(0);\nconst hashCode = \"#\".charCodeAt(0);\n\n/**\n * @param {ExportsField} exportsField the exports field\n * @returns {FieldProcessor} process callback\n */\nmodule.exports.processExportsField = function processExportsField(exportsField) {\n  return createFieldProcessor(buildExportsFieldPathTree(exportsField), assertExportsFieldRequest, assertExportTarget);\n};\n\n/**\n * @param {ImportsField} importsField the exports field\n * @returns {FieldProcessor} process callback\n */\nmodule.exports.processImportsField = function processImportsField(importsField) {\n  return createFieldProcessor(buildImportsFieldPathTree(importsField), assertImportsFieldRequest, assertImportTarget);\n};\n\n/**\n * @param {PathTreeNode} treeRoot root\n * @param {(s: string) => string} assertRequest assertRequest\n * @param {(s: string, f: boolean) => void} assertTarget assertTarget\n * @returns {FieldProcessor} field processor\n */\nfunction createFieldProcessor(treeRoot, assertRequest, assertTarget) {\n  return function fieldProcessor(request, conditionNames) {\n    request = assertRequest(request);\n    const match = findMatch(request, treeRoot);\n    if (match === null) return [];\n    const [mapping, remainRequestIndex] = match;\n\n    /** @type {DirectMapping|null} */\n    let direct = null;\n    if (isConditionalMapping(mapping)) {\n      direct = conditionalMapping( /** @type {ConditionalMapping} */mapping, conditionNames);\n\n      // matching not found\n      if (direct === null) return [];\n    } else {\n      direct = /** @type {DirectMapping} */mapping;\n    }\n    const remainingRequest = remainRequestIndex === request.length + 1 ? undefined : remainRequestIndex < 0 ? request.slice(-remainRequestIndex - 1) : request.slice(remainRequestIndex);\n    return directMapping(remainingRequest, remainRequestIndex < 0, direct, conditionNames, assertTarget);\n  };\n}\n\n/**\n * @param {string} request request\n * @returns {string} updated request\n */\nfunction assertExportsFieldRequest(request) {\n  if (request.charCodeAt(0) !== dotCode) {\n    throw new Error('Request should be relative path and start with \".\"');\n  }\n  if (request.length === 1) return \"\";\n  if (request.charCodeAt(1) !== slashCode) {\n    throw new Error('Request should be relative path and start with \"./\"');\n  }\n  if (request.charCodeAt(request.length - 1) === slashCode) {\n    throw new Error(\"Only requesting file allowed\");\n  }\n  return request.slice(2);\n}\n\n/**\n * @param {string} request request\n * @returns {string} updated request\n */\nfunction assertImportsFieldRequest(request) {\n  if (request.charCodeAt(0) !== hashCode) {\n    throw new Error('Request should start with \"#\"');\n  }\n  if (request.length === 1) {\n    throw new Error(\"Request should have at least 2 characters\");\n  }\n  if (request.charCodeAt(1) === slashCode) {\n    throw new Error('Request should not start with \"#/\"');\n  }\n  if (request.charCodeAt(request.length - 1) === slashCode) {\n    throw new Error(\"Only requesting file allowed\");\n  }\n  return request.slice(1);\n}\n\n/**\n * @param {string} exp export target\n * @param {boolean} expectFolder is folder expected\n */\nfunction assertExportTarget(exp, expectFolder) {\n  if (exp.charCodeAt(0) === slashCode || exp.charCodeAt(0) === dotCode && exp.charCodeAt(1) !== slashCode) {\n    throw new Error(`Export should be relative path and start with \"./\", got ${JSON.stringify(exp)}.`);\n  }\n  const isFolder = exp.charCodeAt(exp.length - 1) === slashCode;\n  if (isFolder !== expectFolder) {\n    throw new Error(expectFolder ? `Expecting folder to folder mapping. ${JSON.stringify(exp)} should end with \"/\"` : `Expecting file to file mapping. ${JSON.stringify(exp)} should not end with \"/\"`);\n  }\n}\n\n/**\n * @param {string} imp import target\n * @param {boolean} expectFolder is folder expected\n */\nfunction assertImportTarget(imp, expectFolder) {\n  const isFolder = imp.charCodeAt(imp.length - 1) === slashCode;\n  if (isFolder !== expectFolder) {\n    throw new Error(expectFolder ? `Expecting folder to folder mapping. ${JSON.stringify(imp)} should end with \"/\"` : `Expecting file to file mapping. ${JSON.stringify(imp)} should not end with \"/\"`);\n  }\n}\n\n/**\n * Trying to match request to field\n * @param {string} request request\n * @param {PathTreeNode} treeRoot path tree root\n * @returns {[MappingValue, number]|null} match or null, number is negative and one less when it's a folder mapping, number is request.length + 1 for direct mappings\n */\nfunction findMatch(request, treeRoot) {\n  if (request.length === 0) {\n    const value = treeRoot.files.get(\"\");\n    return value ? [value, 1] : null;\n  }\n  if (treeRoot.children === null && treeRoot.folder === null && treeRoot.wildcards === null) {\n    const value = treeRoot.files.get(request);\n    return value ? [value, request.length + 1] : null;\n  }\n  let node = treeRoot;\n  let lastNonSlashIndex = 0;\n  let slashIndex = request.indexOf(\"/\", 0);\n\n  /** @type {[MappingValue, number]|null} */\n  let lastFolderMatch = null;\n  const applyFolderMapping = () => {\n    const folderMapping = node.folder;\n    if (folderMapping) {\n      if (lastFolderMatch) {\n        lastFolderMatch[0] = folderMapping;\n        lastFolderMatch[1] = -lastNonSlashIndex - 1;\n      } else {\n        lastFolderMatch = [folderMapping, -lastNonSlashIndex - 1];\n      }\n    }\n  };\n  const applyWildcardMappings = (wildcardMappings, remainingRequest) => {\n    if (wildcardMappings) {\n      for (const [key, target] of wildcardMappings) {\n        if (remainingRequest.startsWith(key)) {\n          if (!lastFolderMatch) {\n            lastFolderMatch = [target, lastNonSlashIndex + key.length];\n          } else if (lastFolderMatch[1] < lastNonSlashIndex + key.length) {\n            lastFolderMatch[0] = target;\n            lastFolderMatch[1] = lastNonSlashIndex + key.length;\n          }\n        }\n      }\n    }\n  };\n  while (slashIndex !== -1) {\n    applyFolderMapping();\n    const wildcardMappings = node.wildcards;\n    if (!wildcardMappings && node.children === null) return lastFolderMatch;\n    const folder = request.slice(lastNonSlashIndex, slashIndex);\n    applyWildcardMappings(wildcardMappings, folder);\n    if (node.children === null) return lastFolderMatch;\n    const newNode = node.children.get(folder);\n    if (!newNode) {\n      return lastFolderMatch;\n    }\n    node = newNode;\n    lastNonSlashIndex = slashIndex + 1;\n    slashIndex = request.indexOf(\"/\", lastNonSlashIndex);\n  }\n  const remainingRequest = lastNonSlashIndex > 0 ? request.slice(lastNonSlashIndex) : request;\n  const value = node.files.get(remainingRequest);\n  if (value) {\n    return [value, request.length + 1];\n  }\n  applyFolderMapping();\n  applyWildcardMappings(node.wildcards, remainingRequest);\n  return lastFolderMatch;\n}\n\n/**\n * @param {ConditionalMapping|DirectMapping|null} mapping mapping\n * @returns {boolean} is conditional mapping\n */\nfunction isConditionalMapping(mapping) {\n  return mapping !== null && typeof mapping === \"object\" && !Array.isArray(mapping);\n}\n\n/**\n * @param {string|undefined} remainingRequest remaining request when folder mapping, undefined for file mappings\n * @param {boolean} subpathMapping true, for subpath mappings\n * @param {DirectMapping|null} mappingTarget direct export\n * @param {Set<string>} conditionNames condition names\n * @param {(d: string, f: boolean) => void} assert asserting direct value\n * @returns {string[]} mapping result\n */\nfunction directMapping(remainingRequest, subpathMapping, mappingTarget, conditionNames, assert) {\n  if (mappingTarget === null) return [];\n  if (typeof mappingTarget === \"string\") {\n    return [targetMapping(remainingRequest, subpathMapping, mappingTarget, assert)];\n  }\n  const targets = [];\n  for (const exp of mappingTarget) {\n    if (typeof exp === \"string\") {\n      targets.push(targetMapping(remainingRequest, subpathMapping, exp, assert));\n      continue;\n    }\n    const mapping = conditionalMapping(exp, conditionNames);\n    if (!mapping) continue;\n    const innerExports = directMapping(remainingRequest, subpathMapping, mapping, conditionNames, assert);\n    for (const innerExport of innerExports) {\n      targets.push(innerExport);\n    }\n  }\n  return targets;\n}\n\n/**\n * @param {string|undefined} remainingRequest remaining request when folder mapping, undefined for file mappings\n * @param {boolean} subpathMapping true, for subpath mappings\n * @param {string} mappingTarget direct export\n * @param {(d: string, f: boolean) => void} assert asserting direct value\n * @returns {string} mapping result\n */\nfunction targetMapping(remainingRequest, subpathMapping, mappingTarget, assert) {\n  if (remainingRequest === undefined) {\n    assert(mappingTarget, false);\n    return mappingTarget;\n  }\n  if (subpathMapping) {\n    assert(mappingTarget, true);\n    return mappingTarget + remainingRequest;\n  }\n  assert(mappingTarget, false);\n  return mappingTarget.replace(/\\*/g, remainingRequest.replace(/\\$/g, \"$$\"));\n}\n\n/**\n * @param {ConditionalMapping} conditionalMapping_ conditional mapping\n * @param {Set<string>} conditionNames condition names\n * @returns {DirectMapping|null} direct mapping if found\n */\nfunction conditionalMapping(conditionalMapping_, conditionNames) {\n  /** @type {[ConditionalMapping, string[], number][]} */\n  let lookup = [[conditionalMapping_, Object.keys(conditionalMapping_), 0]];\n  loop: while (lookup.length > 0) {\n    const [mapping, conditions, j] = lookup[lookup.length - 1];\n    const last = conditions.length - 1;\n    for (let i = j; i < conditions.length; i++) {\n      const condition = conditions[i];\n\n      // assert default. Could be last only\n      if (i !== last) {\n        if (condition === \"default\") {\n          throw new Error(\"Default condition should be last one\");\n        }\n      } else if (condition === \"default\") {\n        const innerMapping = mapping[condition];\n        // is nested\n        if (isConditionalMapping(innerMapping)) {\n          const conditionalMapping = /** @type {ConditionalMapping} */innerMapping;\n          lookup[lookup.length - 1][2] = i + 1;\n          lookup.push([conditionalMapping, Object.keys(conditionalMapping), 0]);\n          continue loop;\n        }\n        return (/** @type {DirectMapping} */innerMapping\n        );\n      }\n      if (conditionNames.has(condition)) {\n        const innerMapping = mapping[condition];\n        // is nested\n        if (isConditionalMapping(innerMapping)) {\n          const conditionalMapping = /** @type {ConditionalMapping} */innerMapping;\n          lookup[lookup.length - 1][2] = i + 1;\n          lookup.push([conditionalMapping, Object.keys(conditionalMapping), 0]);\n          continue loop;\n        }\n        return (/** @type {DirectMapping} */innerMapping\n        );\n      }\n    }\n    lookup.pop();\n  }\n  return null;\n}\n\n/**\n * Internal helper to create path tree node\n * to ensure that each node gets the same hidden class\n * @returns {PathTreeNode} node\n */\nfunction createNode() {\n  return {\n    children: null,\n    folder: null,\n    wildcards: null,\n    files: new Map()\n  };\n}\n\n/**\n * Internal helper for building path tree\n * @param {PathTreeNode} root root\n * @param {string} path path\n * @param {MappingValue} target target\n */\nfunction walkPath(root, path, target) {\n  if (path.length === 0) {\n    root.folder = target;\n    return;\n  }\n  let node = root;\n  // Typical path tree can looks like\n  // root\n  // - files: [\"a.js\", \"b.js\"]\n  // - children:\n  //    node1:\n  //    - files: [\"a.js\", \"b.js\"]\n  let lastNonSlashIndex = 0;\n  let slashIndex = path.indexOf(\"/\", 0);\n  while (slashIndex !== -1) {\n    const folder = path.slice(lastNonSlashIndex, slashIndex);\n    let newNode;\n    if (node.children === null) {\n      newNode = createNode();\n      node.children = new Map();\n      node.children.set(folder, newNode);\n    } else {\n      newNode = node.children.get(folder);\n      if (!newNode) {\n        newNode = createNode();\n        node.children.set(folder, newNode);\n      }\n    }\n    node = newNode;\n    lastNonSlashIndex = slashIndex + 1;\n    slashIndex = path.indexOf(\"/\", lastNonSlashIndex);\n  }\n  if (lastNonSlashIndex >= path.length) {\n    node.folder = target;\n  } else {\n    const file = lastNonSlashIndex > 0 ? path.slice(lastNonSlashIndex) : path;\n    if (file.endsWith(\"*\")) {\n      if (node.wildcards === null) node.wildcards = new Map();\n      node.wildcards.set(file.slice(0, -1), target);\n    } else {\n      node.files.set(file, target);\n    }\n  }\n}\n\n/**\n * @param {ExportsField} field exports field\n * @returns {PathTreeNode} tree root\n */\nfunction buildExportsFieldPathTree(field) {\n  const root = createNode();\n\n  // handle syntax sugar, if exports field is direct mapping for \".\"\n  if (typeof field === \"string\") {\n    root.files.set(\"\", field);\n    return root;\n  } else if (Array.isArray(field)) {\n    root.files.set(\"\", field.slice());\n    return root;\n  }\n  const keys = Object.keys(field);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (key.charCodeAt(0) !== dotCode) {\n      // handle syntax sugar, if exports field is conditional mapping for \".\"\n      if (i === 0) {\n        while (i < keys.length) {\n          const charCode = keys[i].charCodeAt(0);\n          if (charCode === dotCode || charCode === slashCode) {\n            throw new Error(`Exports field key should be relative path and start with \".\" (key: ${JSON.stringify(key)})`);\n          }\n          i++;\n        }\n        root.files.set(\"\", field);\n        return root;\n      }\n      throw new Error(`Exports field key should be relative path and start with \".\" (key: ${JSON.stringify(key)})`);\n    }\n    if (key.length === 1) {\n      root.files.set(\"\", field[key]);\n      continue;\n    }\n    if (key.charCodeAt(1) !== slashCode) {\n      throw new Error(`Exports field key should be relative path and start with \"./\" (key: ${JSON.stringify(key)})`);\n    }\n    walkPath(root, key.slice(2), field[key]);\n  }\n  return root;\n}\n\n/**\n * @param {ImportsField} field imports field\n * @returns {PathTreeNode} root\n */\nfunction buildImportsFieldPathTree(field) {\n  const root = createNode();\n  const keys = Object.keys(field);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (key.charCodeAt(0) !== hashCode) {\n      throw new Error(`Imports field key should start with \"#\" (key: ${JSON.stringify(key)})`);\n    }\n    if (key.length === 1) {\n      throw new Error(`Imports field key should have at least 2 characters (key: ${JSON.stringify(key)})`);\n    }\n    if (key.charCodeAt(1) === slashCode) {\n      throw new Error(`Imports field key should not start with \"#/\" (key: ${JSON.stringify(key)})`);\n    }\n    walkPath(root, key.slice(1), field[key]);\n  }\n  return root;\n}","map":{"version":3,"names":["require","slashCode","charCodeAt","dotCode","hashCode","module","exports","processExportsField","exportsField","createFieldProcessor","buildExportsFieldPathTree","assertExportsFieldRequest","assertExportTarget","processImportsField","importsField","buildImportsFieldPathTree","assertImportsFieldRequest","assertImportTarget","treeRoot","assertRequest","assertTarget","fieldProcessor","request","conditionNames","match","findMatch","mapping","remainRequestIndex","direct","isConditionalMapping","conditionalMapping","remainingRequest","length","undefined","slice","directMapping","Error","exp","expectFolder","JSON","stringify","isFolder","imp","value","files","get","children","folder","wildcards","node","lastNonSlashIndex","slashIndex","indexOf","lastFolderMatch","applyFolderMapping","folderMapping","applyWildcardMappings","wildcardMappings","key","target","startsWith","newNode","Array","isArray","subpathMapping","mappingTarget","assert","targetMapping","targets","push","innerExports","innerExport","replace","conditionalMapping_","lookup","Object","keys","loop","conditions","j","last","i","condition","innerMapping","has","pop","createNode","Map","walkPath","root","path","set","file","endsWith","field","charCode"],"sources":["C:/Users/mahmutcolak/Desktop/rick-and-morty/node_modules/enhanced-resolve/lib/util/entrypoints.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\n/** @typedef {string|(string|ConditionalMapping)[]} DirectMapping */\n/** @typedef {{[k: string]: MappingValue}} ConditionalMapping */\n/** @typedef {ConditionalMapping|DirectMapping|null} MappingValue */\n/** @typedef {Record<string, MappingValue>|ConditionalMapping|DirectMapping} ExportsField */\n/** @typedef {Record<string, MappingValue>} ImportsField */\n\n/**\n * @typedef {Object} PathTreeNode\n * @property {Map<string, PathTreeNode>|null} children\n * @property {MappingValue} folder\n * @property {Map<string, MappingValue>|null} wildcards\n * @property {Map<string, MappingValue>} files\n */\n\n/**\n * Processing exports/imports field\n * @callback FieldProcessor\n * @param {string} request request\n * @param {Set<string>} conditionNames condition names\n * @returns {string[]} resolved paths\n */\n\n/*\nExample exports field:\n{\n  \".\": \"./main.js\",\n  \"./feature\": {\n    \"browser\": \"./feature-browser.js\",\n    \"default\": \"./feature.js\"\n  }\n}\nTerminology:\n\nEnhanced-resolve name keys (\".\" and \"./feature\") as exports field keys.\n\nIf value is string or string[], mapping is called as a direct mapping\nand value called as a direct export.\n\nIf value is key-value object, mapping is called as a conditional mapping\nand value called as a conditional export.\n\nKey in conditional mapping is called condition name.\n\nConditional mapping nested in another conditional mapping is called nested mapping.\n\n----------\n\nExample imports field:\n{\n  \"#a\": \"./main.js\",\n  \"#moment\": {\n    \"browser\": \"./moment/index.js\",\n    \"default\": \"moment\"\n  },\n  \"#moment/\": {\n    \"browser\": \"./moment/\",\n    \"default\": \"moment/\"\n  }\n}\nTerminology:\n\nEnhanced-resolve name keys (\"#a\" and \"#moment/\", \"#moment\") as imports field keys.\n\nIf value is string or string[], mapping is called as a direct mapping\nand value called as a direct export.\n\nIf value is key-value object, mapping is called as a conditional mapping\nand value called as a conditional export.\n\nKey in conditional mapping is called condition name.\n\nConditional mapping nested in another conditional mapping is called nested mapping.\n\n*/\n\nconst slashCode = \"/\".charCodeAt(0);\nconst dotCode = \".\".charCodeAt(0);\nconst hashCode = \"#\".charCodeAt(0);\n\n/**\n * @param {ExportsField} exportsField the exports field\n * @returns {FieldProcessor} process callback\n */\nmodule.exports.processExportsField = function processExportsField(\n\texportsField\n) {\n\treturn createFieldProcessor(\n\t\tbuildExportsFieldPathTree(exportsField),\n\t\tassertExportsFieldRequest,\n\t\tassertExportTarget\n\t);\n};\n\n/**\n * @param {ImportsField} importsField the exports field\n * @returns {FieldProcessor} process callback\n */\nmodule.exports.processImportsField = function processImportsField(\n\timportsField\n) {\n\treturn createFieldProcessor(\n\t\tbuildImportsFieldPathTree(importsField),\n\t\tassertImportsFieldRequest,\n\t\tassertImportTarget\n\t);\n};\n\n/**\n * @param {PathTreeNode} treeRoot root\n * @param {(s: string) => string} assertRequest assertRequest\n * @param {(s: string, f: boolean) => void} assertTarget assertTarget\n * @returns {FieldProcessor} field processor\n */\nfunction createFieldProcessor(treeRoot, assertRequest, assertTarget) {\n\treturn function fieldProcessor(request, conditionNames) {\n\t\trequest = assertRequest(request);\n\n\t\tconst match = findMatch(request, treeRoot);\n\n\t\tif (match === null) return [];\n\n\t\tconst [mapping, remainRequestIndex] = match;\n\n\t\t/** @type {DirectMapping|null} */\n\t\tlet direct = null;\n\n\t\tif (isConditionalMapping(mapping)) {\n\t\t\tdirect = conditionalMapping(\n\t\t\t\t/** @type {ConditionalMapping} */ (mapping),\n\t\t\t\tconditionNames\n\t\t\t);\n\n\t\t\t// matching not found\n\t\t\tif (direct === null) return [];\n\t\t} else {\n\t\t\tdirect = /** @type {DirectMapping} */ (mapping);\n\t\t}\n\n\t\tconst remainingRequest =\n\t\t\tremainRequestIndex === request.length + 1\n\t\t\t\t? undefined\n\t\t\t\t: remainRequestIndex < 0\n\t\t\t\t? request.slice(-remainRequestIndex - 1)\n\t\t\t\t: request.slice(remainRequestIndex);\n\n\t\treturn directMapping(\n\t\t\tremainingRequest,\n\t\t\tremainRequestIndex < 0,\n\t\t\tdirect,\n\t\t\tconditionNames,\n\t\t\tassertTarget\n\t\t);\n\t};\n}\n\n/**\n * @param {string} request request\n * @returns {string} updated request\n */\nfunction assertExportsFieldRequest(request) {\n\tif (request.charCodeAt(0) !== dotCode) {\n\t\tthrow new Error('Request should be relative path and start with \".\"');\n\t}\n\tif (request.length === 1) return \"\";\n\tif (request.charCodeAt(1) !== slashCode) {\n\t\tthrow new Error('Request should be relative path and start with \"./\"');\n\t}\n\tif (request.charCodeAt(request.length - 1) === slashCode) {\n\t\tthrow new Error(\"Only requesting file allowed\");\n\t}\n\n\treturn request.slice(2);\n}\n\n/**\n * @param {string} request request\n * @returns {string} updated request\n */\nfunction assertImportsFieldRequest(request) {\n\tif (request.charCodeAt(0) !== hashCode) {\n\t\tthrow new Error('Request should start with \"#\"');\n\t}\n\tif (request.length === 1) {\n\t\tthrow new Error(\"Request should have at least 2 characters\");\n\t}\n\tif (request.charCodeAt(1) === slashCode) {\n\t\tthrow new Error('Request should not start with \"#/\"');\n\t}\n\tif (request.charCodeAt(request.length - 1) === slashCode) {\n\t\tthrow new Error(\"Only requesting file allowed\");\n\t}\n\n\treturn request.slice(1);\n}\n\n/**\n * @param {string} exp export target\n * @param {boolean} expectFolder is folder expected\n */\nfunction assertExportTarget(exp, expectFolder) {\n\tif (\n\t\texp.charCodeAt(0) === slashCode ||\n\t\t(exp.charCodeAt(0) === dotCode && exp.charCodeAt(1) !== slashCode)\n\t) {\n\t\tthrow new Error(\n\t\t\t`Export should be relative path and start with \"./\", got ${JSON.stringify(\n\t\t\t\texp\n\t\t\t)}.`\n\t\t);\n\t}\n\n\tconst isFolder = exp.charCodeAt(exp.length - 1) === slashCode;\n\n\tif (isFolder !== expectFolder) {\n\t\tthrow new Error(\n\t\t\texpectFolder\n\t\t\t\t? `Expecting folder to folder mapping. ${JSON.stringify(\n\t\t\t\t\t\texp\n\t\t\t\t  )} should end with \"/\"`\n\t\t\t\t: `Expecting file to file mapping. ${JSON.stringify(\n\t\t\t\t\t\texp\n\t\t\t\t  )} should not end with \"/\"`\n\t\t);\n\t}\n}\n\n/**\n * @param {string} imp import target\n * @param {boolean} expectFolder is folder expected\n */\nfunction assertImportTarget(imp, expectFolder) {\n\tconst isFolder = imp.charCodeAt(imp.length - 1) === slashCode;\n\n\tif (isFolder !== expectFolder) {\n\t\tthrow new Error(\n\t\t\texpectFolder\n\t\t\t\t? `Expecting folder to folder mapping. ${JSON.stringify(\n\t\t\t\t\t\timp\n\t\t\t\t  )} should end with \"/\"`\n\t\t\t\t: `Expecting file to file mapping. ${JSON.stringify(\n\t\t\t\t\t\timp\n\t\t\t\t  )} should not end with \"/\"`\n\t\t);\n\t}\n}\n\n/**\n * Trying to match request to field\n * @param {string} request request\n * @param {PathTreeNode} treeRoot path tree root\n * @returns {[MappingValue, number]|null} match or null, number is negative and one less when it's a folder mapping, number is request.length + 1 for direct mappings\n */\nfunction findMatch(request, treeRoot) {\n\tif (request.length === 0) {\n\t\tconst value = treeRoot.files.get(\"\");\n\n\t\treturn value ? [value, 1] : null;\n\t}\n\n\tif (\n\t\ttreeRoot.children === null &&\n\t\ttreeRoot.folder === null &&\n\t\ttreeRoot.wildcards === null\n\t) {\n\t\tconst value = treeRoot.files.get(request);\n\n\t\treturn value ? [value, request.length + 1] : null;\n\t}\n\n\tlet node = treeRoot;\n\tlet lastNonSlashIndex = 0;\n\tlet slashIndex = request.indexOf(\"/\", 0);\n\n\t/** @type {[MappingValue, number]|null} */\n\tlet lastFolderMatch = null;\n\n\tconst applyFolderMapping = () => {\n\t\tconst folderMapping = node.folder;\n\t\tif (folderMapping) {\n\t\t\tif (lastFolderMatch) {\n\t\t\t\tlastFolderMatch[0] = folderMapping;\n\t\t\t\tlastFolderMatch[1] = -lastNonSlashIndex - 1;\n\t\t\t} else {\n\t\t\t\tlastFolderMatch = [folderMapping, -lastNonSlashIndex - 1];\n\t\t\t}\n\t\t}\n\t};\n\n\tconst applyWildcardMappings = (wildcardMappings, remainingRequest) => {\n\t\tif (wildcardMappings) {\n\t\t\tfor (const [key, target] of wildcardMappings) {\n\t\t\t\tif (remainingRequest.startsWith(key)) {\n\t\t\t\t\tif (!lastFolderMatch) {\n\t\t\t\t\t\tlastFolderMatch = [target, lastNonSlashIndex + key.length];\n\t\t\t\t\t} else if (lastFolderMatch[1] < lastNonSlashIndex + key.length) {\n\t\t\t\t\t\tlastFolderMatch[0] = target;\n\t\t\t\t\t\tlastFolderMatch[1] = lastNonSlashIndex + key.length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\twhile (slashIndex !== -1) {\n\t\tapplyFolderMapping();\n\n\t\tconst wildcardMappings = node.wildcards;\n\n\t\tif (!wildcardMappings && node.children === null) return lastFolderMatch;\n\n\t\tconst folder = request.slice(lastNonSlashIndex, slashIndex);\n\n\t\tapplyWildcardMappings(wildcardMappings, folder);\n\n\t\tif (node.children === null) return lastFolderMatch;\n\n\t\tconst newNode = node.children.get(folder);\n\n\t\tif (!newNode) {\n\t\t\treturn lastFolderMatch;\n\t\t}\n\n\t\tnode = newNode;\n\t\tlastNonSlashIndex = slashIndex + 1;\n\t\tslashIndex = request.indexOf(\"/\", lastNonSlashIndex);\n\t}\n\n\tconst remainingRequest =\n\t\tlastNonSlashIndex > 0 ? request.slice(lastNonSlashIndex) : request;\n\n\tconst value = node.files.get(remainingRequest);\n\n\tif (value) {\n\t\treturn [value, request.length + 1];\n\t}\n\n\tapplyFolderMapping();\n\n\tapplyWildcardMappings(node.wildcards, remainingRequest);\n\n\treturn lastFolderMatch;\n}\n\n/**\n * @param {ConditionalMapping|DirectMapping|null} mapping mapping\n * @returns {boolean} is conditional mapping\n */\nfunction isConditionalMapping(mapping) {\n\treturn (\n\t\tmapping !== null && typeof mapping === \"object\" && !Array.isArray(mapping)\n\t);\n}\n\n/**\n * @param {string|undefined} remainingRequest remaining request when folder mapping, undefined for file mappings\n * @param {boolean} subpathMapping true, for subpath mappings\n * @param {DirectMapping|null} mappingTarget direct export\n * @param {Set<string>} conditionNames condition names\n * @param {(d: string, f: boolean) => void} assert asserting direct value\n * @returns {string[]} mapping result\n */\nfunction directMapping(\n\tremainingRequest,\n\tsubpathMapping,\n\tmappingTarget,\n\tconditionNames,\n\tassert\n) {\n\tif (mappingTarget === null) return [];\n\n\tif (typeof mappingTarget === \"string\") {\n\t\treturn [\n\t\t\ttargetMapping(remainingRequest, subpathMapping, mappingTarget, assert)\n\t\t];\n\t}\n\n\tconst targets = [];\n\n\tfor (const exp of mappingTarget) {\n\t\tif (typeof exp === \"string\") {\n\t\t\ttargets.push(\n\t\t\t\ttargetMapping(remainingRequest, subpathMapping, exp, assert)\n\t\t\t);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst mapping = conditionalMapping(exp, conditionNames);\n\t\tif (!mapping) continue;\n\t\tconst innerExports = directMapping(\n\t\t\tremainingRequest,\n\t\t\tsubpathMapping,\n\t\t\tmapping,\n\t\t\tconditionNames,\n\t\t\tassert\n\t\t);\n\t\tfor (const innerExport of innerExports) {\n\t\t\ttargets.push(innerExport);\n\t\t}\n\t}\n\n\treturn targets;\n}\n\n/**\n * @param {string|undefined} remainingRequest remaining request when folder mapping, undefined for file mappings\n * @param {boolean} subpathMapping true, for subpath mappings\n * @param {string} mappingTarget direct export\n * @param {(d: string, f: boolean) => void} assert asserting direct value\n * @returns {string} mapping result\n */\nfunction targetMapping(\n\tremainingRequest,\n\tsubpathMapping,\n\tmappingTarget,\n\tassert\n) {\n\tif (remainingRequest === undefined) {\n\t\tassert(mappingTarget, false);\n\t\treturn mappingTarget;\n\t}\n\tif (subpathMapping) {\n\t\tassert(mappingTarget, true);\n\t\treturn mappingTarget + remainingRequest;\n\t}\n\tassert(mappingTarget, false);\n\treturn mappingTarget.replace(/\\*/g, remainingRequest.replace(/\\$/g, \"$$\"));\n}\n\n/**\n * @param {ConditionalMapping} conditionalMapping_ conditional mapping\n * @param {Set<string>} conditionNames condition names\n * @returns {DirectMapping|null} direct mapping if found\n */\nfunction conditionalMapping(conditionalMapping_, conditionNames) {\n\t/** @type {[ConditionalMapping, string[], number][]} */\n\tlet lookup = [[conditionalMapping_, Object.keys(conditionalMapping_), 0]];\n\n\tloop: while (lookup.length > 0) {\n\t\tconst [mapping, conditions, j] = lookup[lookup.length - 1];\n\t\tconst last = conditions.length - 1;\n\n\t\tfor (let i = j; i < conditions.length; i++) {\n\t\t\tconst condition = conditions[i];\n\n\t\t\t// assert default. Could be last only\n\t\t\tif (i !== last) {\n\t\t\t\tif (condition === \"default\") {\n\t\t\t\t\tthrow new Error(\"Default condition should be last one\");\n\t\t\t\t}\n\t\t\t} else if (condition === \"default\") {\n\t\t\t\tconst innerMapping = mapping[condition];\n\t\t\t\t// is nested\n\t\t\t\tif (isConditionalMapping(innerMapping)) {\n\t\t\t\t\tconst conditionalMapping = /** @type {ConditionalMapping} */ (innerMapping);\n\t\t\t\t\tlookup[lookup.length - 1][2] = i + 1;\n\t\t\t\t\tlookup.push([conditionalMapping, Object.keys(conditionalMapping), 0]);\n\t\t\t\t\tcontinue loop;\n\t\t\t\t}\n\n\t\t\t\treturn /** @type {DirectMapping} */ (innerMapping);\n\t\t\t}\n\n\t\t\tif (conditionNames.has(condition)) {\n\t\t\t\tconst innerMapping = mapping[condition];\n\t\t\t\t// is nested\n\t\t\t\tif (isConditionalMapping(innerMapping)) {\n\t\t\t\t\tconst conditionalMapping = /** @type {ConditionalMapping} */ (innerMapping);\n\t\t\t\t\tlookup[lookup.length - 1][2] = i + 1;\n\t\t\t\t\tlookup.push([conditionalMapping, Object.keys(conditionalMapping), 0]);\n\t\t\t\t\tcontinue loop;\n\t\t\t\t}\n\n\t\t\t\treturn /** @type {DirectMapping} */ (innerMapping);\n\t\t\t}\n\t\t}\n\n\t\tlookup.pop();\n\t}\n\n\treturn null;\n}\n\n/**\n * Internal helper to create path tree node\n * to ensure that each node gets the same hidden class\n * @returns {PathTreeNode} node\n */\nfunction createNode() {\n\treturn {\n\t\tchildren: null,\n\t\tfolder: null,\n\t\twildcards: null,\n\t\tfiles: new Map()\n\t};\n}\n\n/**\n * Internal helper for building path tree\n * @param {PathTreeNode} root root\n * @param {string} path path\n * @param {MappingValue} target target\n */\nfunction walkPath(root, path, target) {\n\tif (path.length === 0) {\n\t\troot.folder = target;\n\t\treturn;\n\t}\n\n\tlet node = root;\n\t// Typical path tree can looks like\n\t// root\n\t// - files: [\"a.js\", \"b.js\"]\n\t// - children:\n\t//    node1:\n\t//    - files: [\"a.js\", \"b.js\"]\n\tlet lastNonSlashIndex = 0;\n\tlet slashIndex = path.indexOf(\"/\", 0);\n\n\twhile (slashIndex !== -1) {\n\t\tconst folder = path.slice(lastNonSlashIndex, slashIndex);\n\t\tlet newNode;\n\n\t\tif (node.children === null) {\n\t\t\tnewNode = createNode();\n\t\t\tnode.children = new Map();\n\t\t\tnode.children.set(folder, newNode);\n\t\t} else {\n\t\t\tnewNode = node.children.get(folder);\n\n\t\t\tif (!newNode) {\n\t\t\t\tnewNode = createNode();\n\t\t\t\tnode.children.set(folder, newNode);\n\t\t\t}\n\t\t}\n\n\t\tnode = newNode;\n\t\tlastNonSlashIndex = slashIndex + 1;\n\t\tslashIndex = path.indexOf(\"/\", lastNonSlashIndex);\n\t}\n\n\tif (lastNonSlashIndex >= path.length) {\n\t\tnode.folder = target;\n\t} else {\n\t\tconst file = lastNonSlashIndex > 0 ? path.slice(lastNonSlashIndex) : path;\n\t\tif (file.endsWith(\"*\")) {\n\t\t\tif (node.wildcards === null) node.wildcards = new Map();\n\t\t\tnode.wildcards.set(file.slice(0, -1), target);\n\t\t} else {\n\t\t\tnode.files.set(file, target);\n\t\t}\n\t}\n}\n\n/**\n * @param {ExportsField} field exports field\n * @returns {PathTreeNode} tree root\n */\nfunction buildExportsFieldPathTree(field) {\n\tconst root = createNode();\n\n\t// handle syntax sugar, if exports field is direct mapping for \".\"\n\tif (typeof field === \"string\") {\n\t\troot.files.set(\"\", field);\n\n\t\treturn root;\n\t} else if (Array.isArray(field)) {\n\t\troot.files.set(\"\", field.slice());\n\n\t\treturn root;\n\t}\n\n\tconst keys = Object.keys(field);\n\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key = keys[i];\n\n\t\tif (key.charCodeAt(0) !== dotCode) {\n\t\t\t// handle syntax sugar, if exports field is conditional mapping for \".\"\n\t\t\tif (i === 0) {\n\t\t\t\twhile (i < keys.length) {\n\t\t\t\t\tconst charCode = keys[i].charCodeAt(0);\n\t\t\t\t\tif (charCode === dotCode || charCode === slashCode) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Exports field key should be relative path and start with \".\" (key: ${JSON.stringify(\n\t\t\t\t\t\t\t\tkey\n\t\t\t\t\t\t\t)})`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\n\t\t\t\troot.files.set(\"\", field);\n\t\t\t\treturn root;\n\t\t\t}\n\n\t\t\tthrow new Error(\n\t\t\t\t`Exports field key should be relative path and start with \".\" (key: ${JSON.stringify(\n\t\t\t\t\tkey\n\t\t\t\t)})`\n\t\t\t);\n\t\t}\n\n\t\tif (key.length === 1) {\n\t\t\troot.files.set(\"\", field[key]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (key.charCodeAt(1) !== slashCode) {\n\t\t\tthrow new Error(\n\t\t\t\t`Exports field key should be relative path and start with \"./\" (key: ${JSON.stringify(\n\t\t\t\t\tkey\n\t\t\t\t)})`\n\t\t\t);\n\t\t}\n\n\t\twalkPath(root, key.slice(2), field[key]);\n\t}\n\n\treturn root;\n}\n\n/**\n * @param {ImportsField} field imports field\n * @returns {PathTreeNode} root\n */\nfunction buildImportsFieldPathTree(field) {\n\tconst root = createNode();\n\n\tconst keys = Object.keys(field);\n\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key = keys[i];\n\n\t\tif (key.charCodeAt(0) !== hashCode) {\n\t\t\tthrow new Error(\n\t\t\t\t`Imports field key should start with \"#\" (key: ${JSON.stringify(key)})`\n\t\t\t);\n\t\t}\n\n\t\tif (key.length === 1) {\n\t\t\tthrow new Error(\n\t\t\t\t`Imports field key should have at least 2 characters (key: ${JSON.stringify(\n\t\t\t\t\tkey\n\t\t\t\t)})`\n\t\t\t);\n\t\t}\n\n\t\tif (key.charCodeAt(1) === slashCode) {\n\t\t\tthrow new Error(\n\t\t\t\t`Imports field key should not start with \"#/\" (key: ${JSON.stringify(\n\t\t\t\t\tkey\n\t\t\t\t)})`\n\t\t\t);\n\t\t}\n\n\t\twalkPath(root, key.slice(1), field[key]);\n\t}\n\n\treturn root;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnDAA,OAAA;AAqDA,MAAMC,SAAS,GAAG,GAAG,CAACC,UAAU,CAAC,CAAC,CAAC;AACnC,MAAMC,OAAO,GAAG,GAAG,CAACD,UAAU,CAAC,CAAC,CAAC;AACjC,MAAME,QAAQ,GAAG,GAAG,CAACF,UAAU,CAAC,CAAC,CAAC;;AAElC;AACA;AACA;AACA;AACAG,MAAM,CAACC,OAAO,CAACC,mBAAmB,GAAG,SAASA,mBAAmBA,CAChEC,YAAY,EACX;EACD,OAAOC,oBAAoB,CAC1BC,yBAAyB,CAACF,YAAY,CAAC,EACvCG,yBAAyB,EACzBC,kBAAkB,CAClB;AACF,CAAC;;AAED;AACA;AACA;AACA;AACAP,MAAM,CAACC,OAAO,CAACO,mBAAmB,GAAG,SAASA,mBAAmBA,CAChEC,YAAY,EACX;EACD,OAAOL,oBAAoB,CAC1BM,yBAAyB,CAACD,YAAY,CAAC,EACvCE,yBAAyB,EACzBC,kBAAkB,CAClB;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,SAASR,oBAAoBA,CAACS,QAAQ,EAAEC,aAAa,EAAEC,YAAY,EAAE;EACpE,OAAO,SAASC,cAAcA,CAACC,OAAO,EAAEC,cAAc,EAAE;IACvDD,OAAO,GAAGH,aAAa,CAACG,OAAO,CAAC;IAEhC,MAAME,KAAK,GAAGC,SAAS,CAACH,OAAO,EAAEJ,QAAQ,CAAC;IAE1C,IAAIM,KAAK,KAAK,IAAI,EAAE,OAAO,E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"},"metadata":{},"sourceType":"script","externalDependencies":[]}