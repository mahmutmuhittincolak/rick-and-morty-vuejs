{"ast":null,"code":"import \"core-js/modules/esnext.typed-array.to-reversed.js\";\nimport \"core-js/modules/esnext.typed-array.to-sorted.js\";\nimport \"core-js/modules/esnext.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\nimport * as leb from \"@webassemblyjs/leb128\";\nimport * as ieee754 from \"@webassemblyjs/ieee754\";\nimport * as utf8 from \"@webassemblyjs/utf8\";\nimport constants from \"@webassemblyjs/helper-wasm-bytecode\";\nimport { encodeNode } from \"../index\";\nfunction assertNotIdentifierNode(n) {\n  if (n.type === \"Identifier\") {\n    throw new Error(\"Unsupported node Identifier\");\n  }\n}\nexport function encodeVersion(v) {\n  var bytes = constants.moduleVersion;\n  bytes[0] = v;\n  return bytes;\n}\nexport function encodeHeader() {\n  return constants.magicModuleHeader;\n}\nexport function encodeU32(v) {\n  var uint8view = new Uint8Array(leb.encodeU32(v));\n  var array = _toConsumableArray(uint8view);\n  return array;\n}\nexport function encodeI32(v) {\n  var uint8view = new Uint8Array(leb.encodeI32(v));\n  var array = _toConsumableArray(uint8view);\n  return array;\n}\nexport function encodeI64(v) {\n  var uint8view = new Uint8Array(leb.encodeI64(v));\n  var array = _toConsumableArray(uint8view);\n  return array;\n}\nexport function encodeVec(elements) {\n  var size = encodeU32(elements.length);\n  return _toConsumableArray(size).concat(_toConsumableArray(elements));\n}\nexport function encodeValtype(v) {\n  var byte = constants.valtypesByString[v];\n  if (typeof byte === \"undefined\") {\n    throw new Error(\"Unknown valtype: \" + v);\n  }\n  return parseInt(byte, 10);\n}\nexport function encodeMutability(v) {\n  var byte = constants.globalTypesByString[v];\n  if (typeof byte === \"undefined\") {\n    throw new Error(\"Unknown mutability: \" + v);\n  }\n  return parseInt(byte, 10);\n}\nexport function encodeUTF8Vec(str) {\n  return encodeVec(utf8.encode(str));\n}\nexport function encodeLimits(n) {\n  var out = [];\n  if (typeof n.max === \"number\") {\n    out.push(0x01);\n    out.push.apply(out, _toConsumableArray(encodeU32(n.min))); // $FlowIgnore: ensured by the typeof\n\n    out.push.apply(out, _toConsumableArray(encodeU32(n.max)));\n  } else {\n    out.push(0x00);\n    out.push.apply(out, _toConsumableArray(encodeU32(n.min)));\n  }\n  return out;\n}\nexport function encodeModuleImport(n) {\n  var out = [];\n  out.push.apply(out, _toConsumableArray(encodeUTF8Vec(n.module)));\n  out.push.apply(out, _toConsumableArray(encodeUTF8Vec(n.name)));\n  switch (n.descr.type) {\n    case \"GlobalType\":\n      {\n        out.push(0x03); // $FlowIgnore: GlobalType ensure that these props exists\n\n        out.push(encodeValtype(n.descr.valtype)); // $FlowIgnore: GlobalType ensure that these props exists\n\n        out.push(encodeMutability(n.descr.mutability));\n        break;\n      }\n    case \"Memory\":\n      {\n        out.push(0x02); // $FlowIgnore\n\n        out.push.apply(out, _toConsumableArray(encodeLimits(n.descr.limits)));\n        break;\n      }\n    case \"Table\":\n      {\n        out.push(0x01);\n        out.push(0x70); // element type\n        // $FlowIgnore\n\n        out.push.apply(out, _toConsumableArray(encodeLimits(n.descr.limits)));\n        break;\n      }\n    case \"FuncImportDescr\":\n      {\n        out.push(0x00); // $FlowIgnore\n\n        assertNotIdentifierNode(n.descr.id); // $FlowIgnore\n\n        out.push.apply(out, _toConsumableArray(encodeU32(n.descr.id.value)));\n        break;\n      }\n    default:\n      throw new Error(\"Unsupport operation: encode module import of type: \" + n.descr.type);\n  }\n  return out;\n}\nexport function encodeSectionMetadata(n) {\n  var out = [];\n  var sectionId = constants.sections[n.section];\n  if (typeof sectionId === \"undefined\") {\n    throw new Error(\"Unknown section: \" + n.section);\n  }\n  if (n.section === \"start\") {\n    /**\n     * This is not implemented yet because it's a special case which\n     * doesn't have a vector in its section.\n     */\n    throw new Error(\"Unsupported section encoding of type start\");\n  }\n  out.push(sectionId);\n  out.push.apply(out, _toConsumableArray(encodeU32(n.size.value)));\n  out.push.apply(out, _toConsumableArray(encodeU32(n.vectorOfSize.value)));\n  return out;\n}\nexport function encodeCallInstruction(n) {\n  var out = [];\n  assertNotIdentifierNode(n.index);\n  out.push(0x10); // $FlowIgnore\n\n  out.push.apply(out, _toConsumableArray(encodeU32(n.index.value)));\n  return out;\n}\nexport function encodeCallIndirectInstruction(n) {\n  var out = []; // $FlowIgnore\n\n  assertNotIdentifierNode(n.index);\n  out.push(0x11); // $FlowIgnore\n\n  out.push.apply(out, _toConsumableArray(encodeU32(n.index.value))); // add a reserved byte\n\n  out.push(0x00);\n  return out;\n}\nexport function encodeModuleExport(n) {\n  var out = [];\n  assertNotIdentifierNode(n.descr.id);\n  var exportTypeByteString = constants.exportTypesByName[n.descr.exportType];\n  if (typeof exportTypeByteString === \"undefined\") {\n    throw new Error(\"Unknown export of type: \" + n.descr.exportType);\n  }\n  var exportTypeByte = parseInt(exportTypeByteString, 10);\n  out.push.apply(out, _toConsumableArray(encodeUTF8Vec(n.name)));\n  out.push(exportTypeByte); // $FlowIgnore\n\n  out.push.apply(out, _toConsumableArray(encodeU32(n.descr.id.value)));\n  return out;\n}\nexport function encodeTypeInstruction(n) {\n  var out = [0x60];\n  var params = n.functype.params.map(function (x) {\n    return x.valtype;\n  }).map(encodeValtype);\n  var results = n.functype.results.map(encodeValtype);\n  out.push.apply(out, _toConsumableArray(encodeVec(params)));\n  out.push.apply(out, _toConsumableArray(encodeVec(results)));\n  return out;\n}\nexport function encodeInstr(n) {\n  var out = [];\n  var instructionName = n.id;\n  if (typeof n.object === \"string\") {\n    instructionName = \"\".concat(n.object, \".\").concat(String(n.id));\n  }\n  var byteString = constants.symbolsByName[instructionName];\n  if (typeof byteString === \"undefined\") {\n    throw new Error(\"encodeInstr: unknown instruction \" + JSON.stringify(instructionName));\n  }\n  var byte = parseInt(byteString, 10);\n  out.push(byte);\n  if (n.args) {\n    n.args.forEach(function (arg) {\n      var encoder = encodeU32; // find correct encoder\n\n      if (n.object === \"i32\") {\n        encoder = encodeI32;\n      }\n      if (n.object === \"i64\") {\n        encoder = encodeI64;\n      }\n      if (n.object === \"f32\") {\n        encoder = ieee754.encodeF32;\n      }\n      if (n.object === \"f64\") {\n        encoder = ieee754.encodeF64;\n      }\n      if (arg.type === \"NumberLiteral\" || arg.type === \"FloatLiteral\" || arg.type === \"LongNumberLiteral\") {\n        // $FlowIgnore\n        out.push.apply(out, _toConsumableArray(encoder(arg.value)));\n      } else {\n        throw new Error(\"Unsupported instruction argument encoding \" + JSON.stringify(arg.type));\n      }\n    });\n  }\n  return out;\n}\nfunction encodeExpr(instrs) {\n  var out = [];\n  instrs.forEach(function (instr) {\n    // $FlowIgnore\n    var n = encodeNode(instr);\n    out.push.apply(out, _toConsumableArray(n));\n  });\n  return out;\n}\nexport function encodeStringLiteral(n) {\n  return encodeUTF8Vec(n.value);\n}\nexport function encodeGlobal(n) {\n  var out = [];\n  var _n$globalType = n.globalType,\n    valtype = _n$globalType.valtype,\n    mutability = _n$globalType.mutability;\n  out.push(encodeValtype(valtype));\n  out.push(encodeMutability(mutability));\n  out.push.apply(out, _toConsumableArray(encodeExpr(n.init)));\n  return out;\n}\nexport function encodeFuncBody(n) {\n  var out = [];\n  out.push(-1); // temporary function body size\n  // FIXME(sven): get the func locals?\n\n  var localBytes = encodeVec([]);\n  out.push.apply(out, _toConsumableArray(localBytes));\n  var funcBodyBytes = encodeExpr(n.body);\n  out[0] = funcBodyBytes.length + localBytes.length;\n  out.push.apply(out, _toConsumableArray(funcBodyBytes));\n  return out;\n}\nexport function encodeIndexInFuncSection(n) {\n  assertNotIdentifierNode(n.index); // $FlowIgnore\n\n  return encodeU32(n.index.value);\n}\nexport function encodeElem(n) {\n  var out = [];\n  assertNotIdentifierNode(n.table); // $FlowIgnore\n\n  out.push.apply(out, _toConsumableArray(encodeU32(n.table.value)));\n  out.push.apply(out, _toConsumableArray(encodeExpr(n.offset))); // $FlowIgnore\n\n  var funcs = n.funcs.reduce(function (acc, x) {\n    return _toConsumableArray(acc).concat(_toConsumableArray(encodeU32(x.value)));\n  }, []);\n  out.push.apply(out, _toConsumableArray(encodeVec(funcs)));\n  return out;\n}","map":{"version":3,"names":["_toConsumableArray","arr","Array","isArray","i","arr2","length","from","leb","ieee754","utf8","constants","encodeNode","assertNotIdentifierNode","n","type","Error","encodeVersion","v","bytes","moduleVersion","encodeHeader","magicModuleHeader","encodeU32","uint8view","Uint8Array","array","encodeI32","encodeI64","encodeVec","elements","size","concat","encodeValtype","byte","valtypesByString","parseInt","encodeMutability","globalTypesByString","encodeUTF8Vec","str","encode","encodeLimits","out","max","push","apply","min","encodeModuleImport","module","name","descr","valtype","mutability","limits","id","value","encodeSectionMetadata","sectionId","sections","section","vectorOfSize","encodeCallInstruction","index","encodeCallIndirectInstruction","encodeModuleExport","exportTypeByteString","exportTypesByName","exportType","exportTypeByte","encodeTypeInstruction","params","functype","map","x","results","encodeInstr","instructionName","object","String","byteString","symbolsByName","JSON","stringify","args","forEach","arg","encoder","encodeF32","encodeF64","encodeExpr","instrs","instr","encodeStringLiteral","encodeGlobal","_n$globalType","globalType","init","encodeFuncBody","localBytes","funcBodyBytes","body","encodeIndexInFuncSection","encodeElem","table","offset","funcs","reduce","acc"],"sources":["C:/Users/mahmutcolak/Desktop/rick-and-morty/node_modules/@webassemblyjs/wasm-gen/esm/encoder/index.js"],"sourcesContent":["function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nimport * as leb from \"@webassemblyjs/leb128\";\nimport * as ieee754 from \"@webassemblyjs/ieee754\";\nimport * as utf8 from \"@webassemblyjs/utf8\";\nimport constants from \"@webassemblyjs/helper-wasm-bytecode\";\nimport { encodeNode } from \"../index\";\n\nfunction assertNotIdentifierNode(n) {\n  if (n.type === \"Identifier\") {\n    throw new Error(\"Unsupported node Identifier\");\n  }\n}\n\nexport function encodeVersion(v) {\n  var bytes = constants.moduleVersion;\n  bytes[0] = v;\n  return bytes;\n}\nexport function encodeHeader() {\n  return constants.magicModuleHeader;\n}\nexport function encodeU32(v) {\n  var uint8view = new Uint8Array(leb.encodeU32(v));\n\n  var array = _toConsumableArray(uint8view);\n\n  return array;\n}\nexport function encodeI32(v) {\n  var uint8view = new Uint8Array(leb.encodeI32(v));\n\n  var array = _toConsumableArray(uint8view);\n\n  return array;\n}\nexport function encodeI64(v) {\n  var uint8view = new Uint8Array(leb.encodeI64(v));\n\n  var array = _toConsumableArray(uint8view);\n\n  return array;\n}\nexport function encodeVec(elements) {\n  var size = encodeU32(elements.length);\n  return _toConsumableArray(size).concat(_toConsumableArray(elements));\n}\nexport function encodeValtype(v) {\n  var byte = constants.valtypesByString[v];\n\n  if (typeof byte === \"undefined\") {\n    throw new Error(\"Unknown valtype: \" + v);\n  }\n\n  return parseInt(byte, 10);\n}\nexport function encodeMutability(v) {\n  var byte = constants.globalTypesByString[v];\n\n  if (typeof byte === \"undefined\") {\n    throw new Error(\"Unknown mutability: \" + v);\n  }\n\n  return parseInt(byte, 10);\n}\nexport function encodeUTF8Vec(str) {\n  return encodeVec(utf8.encode(str));\n}\nexport function encodeLimits(n) {\n  var out = [];\n\n  if (typeof n.max === \"number\") {\n    out.push(0x01);\n    out.push.apply(out, _toConsumableArray(encodeU32(n.min))); // $FlowIgnore: ensured by the typeof\n\n    out.push.apply(out, _toConsumableArray(encodeU32(n.max)));\n  } else {\n    out.push(0x00);\n    out.push.apply(out, _toConsumableArray(encodeU32(n.min)));\n  }\n\n  return out;\n}\nexport function encodeModuleImport(n) {\n  var out = [];\n  out.push.apply(out, _toConsumableArray(encodeUTF8Vec(n.module)));\n  out.push.apply(out, _toConsumableArray(encodeUTF8Vec(n.name)));\n\n  switch (n.descr.type) {\n    case \"GlobalType\":\n      {\n        out.push(0x03); // $FlowIgnore: GlobalType ensure that these props exists\n\n        out.push(encodeValtype(n.descr.valtype)); // $FlowIgnore: GlobalType ensure that these props exists\n\n        out.push(encodeMutability(n.descr.mutability));\n        break;\n      }\n\n    case \"Memory\":\n      {\n        out.push(0x02); // $FlowIgnore\n\n        out.push.apply(out, _toConsumableArray(encodeLimits(n.descr.limits)));\n        break;\n      }\n\n    case \"Table\":\n      {\n        out.push(0x01);\n        out.push(0x70); // element type\n        // $FlowIgnore\n\n        out.push.apply(out, _toConsumableArray(encodeLimits(n.descr.limits)));\n        break;\n      }\n\n    case \"FuncImportDescr\":\n      {\n        out.push(0x00); // $FlowIgnore\n\n        assertNotIdentifierNode(n.descr.id); // $FlowIgnore\n\n        out.push.apply(out, _toConsumableArray(encodeU32(n.descr.id.value)));\n        break;\n      }\n\n    default:\n      throw new Error(\"Unsupport operation: encode module import of type: \" + n.descr.type);\n  }\n\n  return out;\n}\nexport function encodeSectionMetadata(n) {\n  var out = [];\n  var sectionId = constants.sections[n.section];\n\n  if (typeof sectionId === \"undefined\") {\n    throw new Error(\"Unknown section: \" + n.section);\n  }\n\n  if (n.section === \"start\") {\n    /**\n     * This is not implemented yet because it's a special case which\n     * doesn't have a vector in its section.\n     */\n    throw new Error(\"Unsupported section encoding of type start\");\n  }\n\n  out.push(sectionId);\n  out.push.apply(out, _toConsumableArray(encodeU32(n.size.value)));\n  out.push.apply(out, _toConsumableArray(encodeU32(n.vectorOfSize.value)));\n  return out;\n}\nexport function encodeCallInstruction(n) {\n  var out = [];\n  assertNotIdentifierNode(n.index);\n  out.push(0x10); // $FlowIgnore\n\n  out.push.apply(out, _toConsumableArray(encodeU32(n.index.value)));\n  return out;\n}\nexport function encodeCallIndirectInstruction(n) {\n  var out = []; // $FlowIgnore\n\n  assertNotIdentifierNode(n.index);\n  out.push(0x11); // $FlowIgnore\n\n  out.push.apply(out, _toConsumableArray(encodeU32(n.index.value))); // add a reserved byte\n\n  out.push(0x00);\n  return out;\n}\nexport function encodeModuleExport(n) {\n  var out = [];\n  assertNotIdentifierNode(n.descr.id);\n  var exportTypeByteString = constants.exportTypesByName[n.descr.exportType];\n\n  if (typeof exportTypeByteString === \"undefined\") {\n    throw new Error(\"Unknown export of type: \" + n.descr.exportType);\n  }\n\n  var exportTypeByte = parseInt(exportTypeByteString, 10);\n  out.push.apply(out, _toConsumableArray(encodeUTF8Vec(n.name)));\n  out.push(exportTypeByte); // $FlowIgnore\n\n  out.push.apply(out, _toConsumableArray(encodeU32(n.descr.id.value)));\n  return out;\n}\nexport function encodeTypeInstruction(n) {\n  var out = [0x60];\n  var params = n.functype.params.map(function (x) {\n    return x.valtype;\n  }).map(encodeValtype);\n  var results = n.functype.results.map(encodeValtype);\n  out.push.apply(out, _toConsumableArray(encodeVec(params)));\n  out.push.apply(out, _toConsumableArray(encodeVec(results)));\n  return out;\n}\nexport function encodeInstr(n) {\n  var out = [];\n  var instructionName = n.id;\n\n  if (typeof n.object === \"string\") {\n    instructionName = \"\".concat(n.object, \".\").concat(String(n.id));\n  }\n\n  var byteString = constants.symbolsByName[instructionName];\n\n  if (typeof byteString === \"undefined\") {\n    throw new Error(\"encodeInstr: unknown instruction \" + JSON.stringify(instructionName));\n  }\n\n  var byte = parseInt(byteString, 10);\n  out.push(byte);\n\n  if (n.args) {\n    n.args.forEach(function (arg) {\n      var encoder = encodeU32; // find correct encoder\n\n      if (n.object === \"i32\") {\n        encoder = encodeI32;\n      }\n\n      if (n.object === \"i64\") {\n        encoder = encodeI64;\n      }\n\n      if (n.object === \"f32\") {\n        encoder = ieee754.encodeF32;\n      }\n\n      if (n.object === \"f64\") {\n        encoder = ieee754.encodeF64;\n      }\n\n      if (arg.type === \"NumberLiteral\" || arg.type === \"FloatLiteral\" || arg.type === \"LongNumberLiteral\") {\n        // $FlowIgnore\n        out.push.apply(out, _toConsumableArray(encoder(arg.value)));\n      } else {\n        throw new Error(\"Unsupported instruction argument encoding \" + JSON.stringify(arg.type));\n      }\n    });\n  }\n\n  return out;\n}\n\nfunction encodeExpr(instrs) {\n  var out = [];\n  instrs.forEach(function (instr) {\n    // $FlowIgnore\n    var n = encodeNode(instr);\n    out.push.apply(out, _toConsumableArray(n));\n  });\n  return out;\n}\n\nexport function encodeStringLiteral(n) {\n  return encodeUTF8Vec(n.value);\n}\nexport function encodeGlobal(n) {\n  var out = [];\n  var _n$globalType = n.globalType,\n      valtype = _n$globalType.valtype,\n      mutability = _n$globalType.mutability;\n  out.push(encodeValtype(valtype));\n  out.push(encodeMutability(mutability));\n  out.push.apply(out, _toConsumableArray(encodeExpr(n.init)));\n  return out;\n}\nexport function encodeFuncBody(n) {\n  var out = [];\n  out.push(-1); // temporary function body size\n  // FIXME(sven): get the func locals?\n\n  var localBytes = encodeVec([]);\n  out.push.apply(out, _toConsumableArray(localBytes));\n  var funcBodyBytes = encodeExpr(n.body);\n  out[0] = funcBodyBytes.length + localBytes.length;\n  out.push.apply(out, _toConsumableArray(funcBodyBytes));\n  return out;\n}\nexport function encodeIndexInFuncSection(n) {\n  assertNotIdentifierNode(n.index); // $FlowIgnore\n\n  return encodeU32(n.index.value);\n}\nexport function encodeElem(n) {\n  var out = [];\n  assertNotIdentifierNode(n.table); // $FlowIgnore\n\n  out.push.apply(out, _toConsumableArray(encodeU32(n.table.value)));\n  out.push.apply(out, _toConsumableArray(encodeExpr(n.offset))); // $FlowIgnore\n\n  var funcs = n.funcs.reduce(function (acc, x) {\n    return _toConsumableArray(acc).concat(_toConsumableArray(encodeU32(x.value)));\n  }, []);\n  out.push.apply(out, _toConsumableArray(encodeVec(funcs)));\n  return out;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}