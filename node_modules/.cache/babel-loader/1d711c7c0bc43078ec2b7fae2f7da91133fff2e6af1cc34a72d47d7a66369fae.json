{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeNode = encodeNode;\nexports.encodeU32 = void 0;\nvar encoder = _interopRequireWildcard(require(\"./encoder\"));\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nfunction encodeNode(n) {\n  switch (n.type) {\n    case \"ModuleImport\":\n      // $FlowIgnore: ModuleImport ensure that the node is well formated\n      return encoder.encodeModuleImport(n);\n    case \"SectionMetadata\":\n      // $FlowIgnore: SectionMetadata ensure that the node is well formated\n      return encoder.encodeSectionMetadata(n);\n    case \"CallInstruction\":\n      // $FlowIgnore: SectionMetadata ensure that the node is well formated\n      return encoder.encodeCallInstruction(n);\n    case \"CallIndirectInstruction\":\n      // $FlowIgnore: SectionMetadata ensure that the node is well formated\n      return encoder.encodeCallIndirectInstruction(n);\n    case \"TypeInstruction\":\n      return encoder.encodeTypeInstruction(n);\n    case \"Instr\":\n      // $FlowIgnore\n      return encoder.encodeInstr(n);\n    case \"ModuleExport\":\n      // $FlowIgnore: SectionMetadata ensure that the node is well formated\n      return encoder.encodeModuleExport(n);\n    case \"Global\":\n      // $FlowIgnore\n      return encoder.encodeGlobal(n);\n    case \"Func\":\n      return encoder.encodeFuncBody(n);\n    case \"IndexInFuncSection\":\n      return encoder.encodeIndexInFuncSection(n);\n    case \"StringLiteral\":\n      return encoder.encodeStringLiteral(n);\n    case \"Elem\":\n      return encoder.encodeElem(n);\n    default:\n      throw new Error(\"Unsupported encoding for node of type: \" + JSON.stringify(n.type));\n  }\n}\nvar encodeU32 = encoder.encodeU32;\nexports.encodeU32 = encodeU32;","map":{"version":3,"names":["Object","defineProperty","exports","value","encodeNode","encodeU32","encoder","_interopRequireWildcard","require","obj","__esModule","newObj","key","prototype","hasOwnProperty","call","desc","getOwnPropertyDescriptor","get","set","default","n","type","encodeModuleImport","encodeSectionMetadata","encodeCallInstruction","encodeCallIndirectInstruction","encodeTypeInstruction","encodeInstr","encodeModuleExport","encodeGlobal","encodeFuncBody","encodeIndexInFuncSection","encodeStringLiteral","encodeElem","Error","JSON","stringify"],"sources":["C:/Users/mahmutcolak/Desktop/rick-and-morty/node_modules/@webassemblyjs/wasm-gen/lib/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeNode = encodeNode;\nexports.encodeU32 = void 0;\n\nvar encoder = _interopRequireWildcard(require(\"./encoder\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction encodeNode(n) {\n  switch (n.type) {\n    case \"ModuleImport\":\n      // $FlowIgnore: ModuleImport ensure that the node is well formated\n      return encoder.encodeModuleImport(n);\n\n    case \"SectionMetadata\":\n      // $FlowIgnore: SectionMetadata ensure that the node is well formated\n      return encoder.encodeSectionMetadata(n);\n\n    case \"CallInstruction\":\n      // $FlowIgnore: SectionMetadata ensure that the node is well formated\n      return encoder.encodeCallInstruction(n);\n\n    case \"CallIndirectInstruction\":\n      // $FlowIgnore: SectionMetadata ensure that the node is well formated\n      return encoder.encodeCallIndirectInstruction(n);\n\n    case \"TypeInstruction\":\n      return encoder.encodeTypeInstruction(n);\n\n    case \"Instr\":\n      // $FlowIgnore\n      return encoder.encodeInstr(n);\n\n    case \"ModuleExport\":\n      // $FlowIgnore: SectionMetadata ensure that the node is well formated\n      return encoder.encodeModuleExport(n);\n\n    case \"Global\":\n      // $FlowIgnore\n      return encoder.encodeGlobal(n);\n\n    case \"Func\":\n      return encoder.encodeFuncBody(n);\n\n    case \"IndexInFuncSection\":\n      return encoder.encodeIndexInFuncSection(n);\n\n    case \"StringLiteral\":\n      return encoder.encodeStringLiteral(n);\n\n    case \"Elem\":\n      return encoder.encodeElem(n);\n\n    default:\n      throw new Error(\"Unsupported encoding for node of type: \" + JSON.stringify(n.type));\n  }\n}\n\nvar encodeU32 = encoder.encodeU32;\nexports.encodeU32 = encodeU32;"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,UAAU,GAAGA,UAAU;AAC/BF,OAAO,CAACG,SAAS,GAAG,KAAK,CAAC;AAE1B,IAAIC,OAAO,GAAGC,uBAAuB,CAACC,OAAO,CAAC,WAAW,CAAC,CAAC;AAE3D,SAASD,uBAAuBA,CAACE,GAAG,EAAE;EAAE,IAAIA,GAAG,IAAIA,GAAG,CAACC,UAAU,EAAE;IAAE,OAAOD,GAAG;EAAE,CAAC,MAAM;IAAE,IAAIE,MAAM,GAAG,CAAC,CAAC;IAAE,IAAIF,GAAG,IAAI,IAAI,EAAE;MAAE,KAAK,IAAIG,GAAG,IAAIH,GAAG,EAAE;QAAE,IAAIT,MAAM,CAACa,SAAS,CAACC,cAAc,CAACC,IAAI,CAACN,GAAG,EAAEG,GAAG,CAAC,EAAE;UAAE,IAAII,IAAI,GAAGhB,MAAM,CAACC,cAAc,IAAID,MAAM,CAACiB,wBAAwB,GAAGjB,MAAM,CAACiB,wBAAwB,CAACR,GAAG,EAAEG,GAAG,CAAC,GAAG,CAAC,CAAC;UAAE,IAAII,IAAI,CAACE,GAAG,IAAIF,IAAI,CAACG,GAAG,EAAE;YAAEnB,MAAM,CAACC,cAAc,CAACU,MAAM,EAAEC,GAAG,EAAEI,IAAI,CAAC;UAAE,CAAC,MAAM;YAAEL,MAAM,CAACC,GAAG,CAAC,GAAGH,GAAG,CAACG,GAAG,CAAC;UAAE;QAAE;MAAE;IAAE;IAAED,MAAM,CAACS,OAAO,GAAGX,GAAG;IAAE,OAAOE,MAAM;EAAE;AAAE;AAEvd,SAASP,UAAUA,CAACiB,CAAC,EAAE;EACrB,QAAQA,CAAC,CAACC,IAAI;IACZ,KAAK,cAAc;MACjB;MACA,OAAOhB,OAAO,CAACiB,kBAAkB,CAACF,CAAC,CAAC;IAEtC,KAAK,iBAAiB;MACpB;MACA,OAAOf,OAAO,CAACkB,qBAAqB,CAACH,CAAC,CAAC;IAEzC,KAAK,iBAAiB;MACpB;MACA,OAAOf,OAAO,CAACmB,qBAAqB,CAACJ,CAAC,CAAC;IAEzC,KAAK,yBAAyB;MAC5B;MACA,OAAOf,OAAO,CAACoB,6BAA6B,CAACL,CAAC,CAAC;IAEjD,KAAK,iBAAiB;MACpB,OAAOf,OAAO,CAACqB,qBAAqB,CAACN,CAAC,CAAC;IAEzC,KAAK,OAAO;MACV;MACA,OAAOf,OAAO,CAACsB,WAAW,CAACP,CAAC,CAAC;IAE/B,KAAK,cAAc;MACjB;MACA,OAAOf,OAAO,CAACuB,kBAAkB,CAACR,CAAC,CAAC;IAEtC,KAAK,QAAQ;MACX;MACA,OAAOf,OAAO,CAACwB,YAAY,CAACT,CAAC,CAAC;IAEhC,KAAK,MAAM;MACT,OAAOf,OAAO,CAACyB,cAAc,CAACV,CAAC,CAAC;IAElC,KAAK,oBAAoB;MACvB,OAAOf,OAAO,CAAC0B,wBAAwB,CAACX,CAAC,CAAC;IAE5C,KAAK,eAAe;MAClB,OAAOf,OAAO,CAAC2B,mBAAmB,CAACZ,CAAC,CAAC;IAEvC,KAAK,MAAM;MACT,OAAOf,OAAO,CAAC4B,UAAU,CAACb,CAAC,CAAC;IAE9B;MACE,MAAM,IAAIc,KAAK,CAAC,yCAAyC,GAAGC,IAAI,CAACC,SAAS,CAAChB,CAAC,CAACC,IAAI,CAAC,CAAC;EAAC;AAE1F;AAEA,IAAIjB,SAAS,GAAGC,OAAO,CAACD,SAAS;AACjCH,OAAO,CAACG,SAAS,GAAGA,SAAS"},"metadata":{},"sourceType":"script","externalDependencies":[]}